-----------------------------------------------------------------------------


    €€€€€ø                                             €€€€€€ø  €€€€€€ø
    €€⁄ƒƒ€ø  €€€ø€€€€€€ø  €€€€€€€€ø  €€€€€€ø €€€€€€€€ø€⁄ƒƒƒƒƒ€ø €⁄ƒƒƒƒ€ø
    €€≥   €ø  €⁄Ÿ €⁄ƒƒƒ€ø  €€⁄ƒƒƒƒŸ €€⁄ƒƒƒƒ€ø¿ƒƒ€€⁄ƒƒŸ€≥     €≥ €‹‹‹‹‹€≥
    €€≥    €ø €≥  €‹‹‹€⁄Ÿ  €€€€ø   €€⁄Ÿ    ¿Ÿ   €€≥   €≥   €ø€≥ €⁄ƒƒƒƒƒ€ø
    €€≥    €≥ €≥  €⁄ƒƒƒ€ø  €€⁄ƒŸ   €€≥     €ø   €€≥   €≥    €⁄Ÿ €≥     €≥
    €€€€€€€⁄Ÿ€€€ø€€€ø €€€ø€€€€€€€€ø €€€€€€€⁄Ÿ   €€≥    €€€€€⁄€€ø€€€€€€€⁄Ÿ
    ¿ƒƒƒƒƒƒŸ ¿ƒƒŸ¿ƒƒŸ ¿ƒƒŸ¿ƒƒƒƒƒƒƒŸ ¿ƒƒƒƒƒƒŸ    ¿ƒŸ    ¿ƒƒƒƒŸ¿ƒŸ¿ƒƒƒƒƒƒŸ

                          version 1.61 ˛ 1/6/1999


            DirectQB: a Game Programming Library for QuickBasic 4.5
      (but it could be easily adapted to your own programming language!)

               by Angelo Mottola - Enhanced Creations 1998-99



-----------------------------------------------------------------------------

What's new in version 1.6 / 1.61

Now, as always, here's a brief description on the new library features:

- EMS memory can now be used also to store your own custom data
- Sound output quality improved a lot (no more "clicks"!!! You can now play
  at 22Khz without problems, gaining almost the same quality of BWSB!)
- DQBemsSeg has been replaced by DQBmapLayer, which is more versatile for
  advanced memory handling
- Blender map system completely rewritten, now allows to use up to 10 bmaps
  at the same time, with a smarter memory management (no more 64K required
  for each bmap!)
- DQBloadLayer and DQBsaveLayer have been replaced by DQBloadImage and
  DQBsaveImage, modified versions of the above routines, that allow to load
  and save images of any size, using BSV,BMP or PCX formats
- Text output routines improved; now you can use all the text style
  combinations at the same time, plus some bugs have been fixed
- All the library has been a little accelerated
- Texture mapping now support bilinear filtering (but you need a gradient
  palette for it to work correctly)
- DQBcopyBlendLayer and DQBcopyHitLayer added; the first blends a layer onto
  another one, and the second creates a collision layer to be used with the
  DQBcollideOnLayer function
- Datafile support: added a new datafile decoding module, plus an encoder
  program that allows you to create your custom compressed datafiles, also
  encrypted by a user-specified password. A datafile can store images, sprites,
  sounds, palettes, fonts, mouse cursors and any kind of user defined data;
  you can decode this data on the fly by your program (if you know the right
  datafile password of course!)
- DQBwaitFrame SUB replaced by DQBframeReady FUNCTION, which returns true if
  enough time has passed to syncronize graphics to the framerate, otherwise
  false
- DQBgline draws a line interpolating colors between the two indexes specified
  at the endpoints
- Default font now support extended characters (ascii code 128-255)
- Directory handling routines now work with Windows long filenames (if under
  Windows)
- DQB Library Manager now asks first where is your copy of QB 4.5, and scans
  the drive for it only if you tell it to do so
- DQBtools modified to display extended characters and long filenames


List of new functions and modified ones:

DQBinit, DQBid$, DQBemsSeg, DQBmapLayer, DQBclose, DQBwaitFrame, DQBframeReady,
DQBpeek, DQBpoke, DQBfilterBox, DQBbPut, DQBcopyBlendLayer, DQBcreateBMap,
DQBsetBMap, DQBgetBMap, DQBloadBMap, DQBsaveBMap, DQBremoveBMap, DQBfttri,
DQBopenDataFile, DQBunpackFont, DQBunpackImage, DQBunpackSprite,
DQBunpackSound, DQBunpackPal, DQBunpackBMap, DQBunpackCursor, DQBunpackUser,
DQBcloseDataFile, DQBdir$, DQBpath$, DQBchDir, DQBcopyHitLayer, DQBgline,
DQBprint, DQBsetBIOSfont, DQBsetTextBMap, DQBloadLayer, DQBloadImage,
DQBsaveLayer, DQBsaveImage, DQBpalRotate, DQBinstallSB, DQBplaySound, DQBpPut


Check out part 2 of this manual for details on each function. Also, as the
library still has limitations, be sure to check out section 1.7.

This will probably be the last major release of the DirectQB library; maybe
other minor versions will come out, but they'll be almost entirely about
bugfixes... About the matrix-calculations module, I still think it would be
useful, so maybe I'll create it someday. The same goes for a possible modem
handling module: this would allow multiplayer, but only in direct connections,
thus not along the Internet (i.e. without TCP/IP support)
For now, use this version for your works, as it's stable and it'll be around
for a lot of time... Have fun with DirectQB, and remember to visit the
Enhanced Creations website at

                          http://ec.quickbasic.com

If you have any questions, post a message on the wwwboard there, and you'll
get a reply!


=============================================================================


TABLE OF CONTENTS

1     Introduction to DirectQB
  1.1   Legal stuff
  1.2   What is DirectQB
  1.3   System requirements
  1.4   Features
  1.5   Installing the library
  1.6   Basic concepts
  1.7   Limits of the library
2     Functions reference
        DQBangle FUNCTION
        DQBasc FUNCTION
        DQBbgtri SUB
        DQBbox SUB
        DQBboxf SUB
        DQBbPut SUB
        DQBbtri SUB
        DQBbttri SUB
        DQBchDir FUNCTION
        DQBclearLayer SUB
        DQBclose SUB
        DQBcloseDataFile SUB
        DQBcloseFLI SUB
        DQBcollide FUNCTION
        DQBcollideOnLayer FUNCTION
        DQBcopyBlendLayer SUB
        DQBcopyHitLayer SUB
        DQBcopyLayer SUB
        DQBcopyTransLayer SUB
        DQBcreateBMap FUNCTION
        DQBdir$ FUNCTION
        DQBdrive$ FUNCTION
        DQBellipse SUB
        DQBerror$ FUNCTION
        DQBfadeIn SUB
        DQBfadeStepIn SUB
        DQBfadeStepTo SUB
        DQBfadeTo SUB
        DQBfilterBox SUB
        DQBfindCol FUNCTION
        DQBfindPalCol FUNCTION
        DQBfPut SUB
        DQBframeReady FUNCTION
        DQBfttri SUB
        DQBget SUB
        DQBgetBMap FUNCTION
        DQBgetCol SUB
        DQBgetPal SUB
        DQBgline SUB
        DQBgtri SUB
        DQBhPut SUB
        DQBid$ FUNCTION
        DQBinit FUNCTION
        DQBinitText SUB
        DQBinitVGA SUB
        DQBinkey$ FUNCTION
        DQBinstallKeyboard SUB
        DQBinstallSB FUNCTION
        DQBinUse FUNCTION
        DQBjoyDetected FUNCTION
        DQBjoyFire FUNCTION
        DQBjoyMove FUNCTION
        DQBjoyX FUNCTION
        DQBjoyY FUNCTION
        DQBkey FUNCTION
        DQBlen FUNCTION
        DQBline SUB
        DQBloadBMap FUNCTION
        DQBloadFont FUNCTION
        DQBloadImage FUNCTION
        DQBloadRawSound FUNCTION
        DQBloadSound FUNCTION
        DQBmapLayer FUNCTION
        DQBmouseDetected FUNCTION
        DQBmouseHide SUB
        DQBmouseLB FUNCTION
        DQBmouseRB FUNCTION
        DQBmouseShow SUB
        DQBmouseX FUNCTION
        DQBmouseY FUNCTION
        DQBmPut SUB
        DQBnumDrives FUNCTION
        DQBopenDataFile FUNCTION
        DQBopenFLI FUNCTION
        DQBpaint SUB
        DQBpalOff SUB
        DQBpalRotate SUB
        DQBpath$ FUNCTION
        DQBpauseSound SUB
        DQBpeek SUB
        DQBplayFLI FUNCTION
        DQBplayFLIstep SUB
        DQBplaySound SUB
        DQBpoint FUNCTION
        DQBpoke SUB
        DQBpollJoy SUB
        DQBpPut SUB
        DQBprint SUB
        DQBprints SUB
        DQBpset SUB
        DQBput SUB
        DQBputOver SUB
        DQBreadBit FUNCTION
        DQBreadKey FUNCTION
        DQBremoveBMap SUB
        DQBremoveKeyboard SUB
        DQBremoveSB SUB
        DQBresetBit FUNCTION
        DQBresetJoy SUB
        DQBresetMouse SUB
        DQBresumeSound SUB
        DQBrPut SUB
        DQBsaveBMap FUNCTION
        DQBsaveImage FUNCTION
        DQBscroll SUB
        DQBscrollArea SUB
        DQBsetBaseLayer FUNCTION
        DQBsetBIOSfont SUB
        DQBsetBit FUNCTION
        DQBsetBMap SUB
        DQBsetClipBox SUB
        DQBsetCol SUB
        DQBsetCollideMethod SUB
        DQBsetDrive SUB
        DQBsetFont SUB
        DQBsetFontTexture SUB
        DQBsetFrameRate SUB
        DQBsetMousePos SUB
        DQBsetMouseRange SUB
        DQBsetMouseShape SUB
        DQBsetMouseSpeed SUB
        DQBsetPal SUB
        DQBsetSolidPut SUB
        DQBsetTextBackCol SUB
        DQBsetTextBMap SUB
        DQBsetTextSpacing SUB
        DQBsetTextStyle SUB
        DQBsetTextureSize SUB
        DQBsetTransPut SUB
        DQBsetVoiceVol SUB
        DQBsetVolume SUB
        DQBshiftLeft FUNCTION
        DQBshiftRight FUNCTION
        DQBsize FUNCTION
        DQBsort SUB
        DQBsPut SUB
        DQBstopVoice SUB
        DQBtoggleBit FUNCTION
        DQBtPut SUB
        DQBtri SUB
        DQBttri SUB
        DQBunpackBMap FUNCTION
        DQBunpackCursor FUNCTION
        DQBunpackFont FUNCTION
        DQBunpackImage FUNCTION
        DQBunpackPal FUNCTION
        DQBunpackSound FUNCTION
        DQBunpackSprite FUNCTION
        DQBunpackUser FUNCTION
        DQBver FUNCTION
        DQBwait SUB
        DQBwaitKey SUB
        DQBxPut SUB
APPENDIX A    Library constants
APPENDIX B    Keyboard scancodes list
APPENDIX C    Library file formats
APPENDIX D    Known bugs
APPENDIX E    Versions history
APPENDIX F    Inside library modules
APPENDIX G    Error messages
Credits and final words

-----------------------------------------------------------------------------



=============================================================================
1.  INTRODUCTION TO DIRECTQB
=============================================================================


-----------------------------------------------------------------------------
1.1 - Legal stuff
-----------------------------------------------------------------------------

THIS SOFTWARE FOLLOWS THE RULES OF THE FREEWARE CONCEPT: YOU CAN SHARE IT
WITH YOUR FRIENDS, AND YOU'RE ENCOURAGED IN DOING SO, BUT THE AUTHOR IS ANYWAY
NOT LIABLE FOR ANY DAMAGES CAUSED BY THE USE OF THIS LIBRARY. IT IS NOT
COPYRIGHTED, BUT IF YOU WANT TO MODIFY IT, PLEASE TELL ME FIRST.
IF YOU USE THE DIRECTQB ROUTINES, PLEASE GIVE ME SOME CREDITS IN YOUR PROGRAM.


-----------------------------------------------------------------------------
1.2 - What is DirectQB
-----------------------------------------------------------------------------

DirectQB is a game programming library entirely written in assembly 386 for
QuickBasic 4.5. It has been mainly coded to fill the void into the weak
graphics, input and sound capabilities of QB; it works in screen mode 13h
(320x200 with 256 colors - the common SCREEN 13 for QB), supports keyboard,
mouse and joysticks as input devices, and has a built-in sound engine that
works with almost any SB compatible sound card. It has really lots of
features, as you'll discover reading this manual...


-----------------------------------------------------------------------------
1.3 - System requirements
-----------------------------------------------------------------------------

First of all you'll need a copy of QuickBasic 4.5. DirectQB is a quicklibrary,
and therefore is made to run only under this programming environment.
As DirectQB has been entirely coded in assembly using several advanced 386
instructions, a 386 or better CPU is required. EMS is also needed in order
to have off-screen buffers (though you can also have them stored in base mem),
the so named "layers", as we'll see later. For every layer you need 64 KB of
free base or EMS memory; if you don't know what is EMS, or you've problems
with it, try adding these lines at the beginning of your CONFIG.SYS file:

DEVICE=C:\WINDOWS\HIMEM.SYS
DEVICE=C:\WINDOWS\EMM386.EXE <amount> RAM

Where <amount> must be a number specifying the amount of EMS memory in KB to
make available under DOS. Here I also suppose you have Windows 95 under the
C:\WINDOWS directory. So to have 4 MB of free EMS memory, you should add:

DEVICE=C:\WINDOWS\EMM386.EXE 4000 RAM

That's all. After adding those lines, reboot your system, and EMS will be
available, and ready to be used by the library.

To work with the sound engine, you'll need at least a SoundBlaster 2.0
compatible sound card; DirectQB uses autoinit mode for DMA transfers, so
a DSP version 2.00 (contained in the SB 2.0) or better is required. If you
use DQBinstallSB with autodetection mode, you must have set the BLASTER
environmental variable. Add the following line to your AUTOEXEC.BAT file:

SET BLASTER = Aaaa Ii Dd

Where "aaa" is the exadecimal base address of your sound card (commonly 220),
"i" is the IRQ number and "d" is the DMA channel to be used. A common setting
would be like this:

SET BLASTER = A220 I7 D1

which sets the base address as 220h, IRQ 7 and DMA channel 1. DirectQB
supports any range of base address, IRQ 2, 3, 5 and 7, and DMA channels 0 to
3. There are other settings for the BLASTER variable, such as H and T, but
I'll not explain them here, as they're not required for our purposes.

The sound engine also requires 16K of extra CONVENTIONAL memory, as it builds
an internal volume table at runtime; you can anyway avoid this requirement,
if you don't need to use custom volumes for each of the activated voices.

The blender map system is another way to keep your base memory busy; the
amount of it needed to use a single bmap depends on the bmap itself, and can
vary from 256 bytes up to 64K per bmap. You can have up to 10 bmaps active
at the same time.

It is expected that you run into an out of memory error if you call the DQB
functions that require extra base memory without calling the SETMEM function
first. See the QB online help and the examples on this manual for details on
how to use it.

Well, as by now there are no more requirements to run DirectQB.


-----------------------------------------------------------------------------
1.4 - Features
-----------------------------------------------------------------------------

DirectQB version 1.6 has the following features:

Graphical features:

- Supports 320x200 with 256 colors video mode, with almost unlimited number
  of off-screen buffers stored into EMS memory or into conventional memory.
  EMS is automatically handled for you by the library
- All the functions act on the screen as well as on the off-screen buffers
- Several drawing primitives, including pset, line, gline, ellipse, box,
  full box and paint
- Fast sprite handling functions, compatible with standard GET and PUT, also
  with support for sprite flipping, scaling, roto-zooming and translucency,
  and direct sprite drawing from a layer onto another one without requiring
  any external QB array
- Sprites collision detection with selectable method (bounding box or pixel
  perfect), and support for collision layers
- Color blending routines to handle up to 10 customizable blender maps,
  allowing to create any color combination
- Clipping for almost all the graphical functions
- Loads and saves images in BSAVE, BMP and PCX format in any size
- Plays FLI animation files
- Font routines with customizable font set, non-fixed sized fonts support and
  custom styles, such as bold, italic, underlined, or a combination of them,
  also with support for color blending and textured text
- Smooth palette handling with routines to fade the current palette into any
  new one as well as into any specified color, and to rotate colors
- Multidirectional scrolling for an entire layer or only a portion of it
- Transparent screen copy for parallax scrolling effects, blended layer copy
  for huge translucency effect
- Fast triangle drawing primitives allowing flat-shading, gouraud-shading
  and affine texture mapping (also with support for bi-linear filtering),
  all with support for color blending

Input features:

- Custom keyboard interrupt handler that allows to know the state (pressed or
  released) of any key at any time
- Several keyboard handling functions working under this IRQ handler, to read
  a key, to get the ascii code from its scancode, and more
- Fast and easy to use joystick routines, with auto detection and auto
  calibration, with support for 1 or 2 2-button joysticks or 1 4-button joypad
- Mouse handler: the mouse variables (coordinates and buttons status) are
  automatically updated when you move the mouse, allowing you to know the
  actual mouse state at any time without calling other routines
- Mouse routines to change the cursor shape, mouse range, speed and position

Sound features:

- IRQ driven sound engine for fast and easy sounds playback via DMA transfers
- Loads and plays sound effects directly from EMS
- Supports only 8-bit mono WAV files up to 22000 Hz
- Customizable number of channels, from 1 up to 32, for up to 32 sound effects
  simultaneously playing
- Realtime sound resampling
- Customizable volume setting for each of the voices
- Customizable master volume setting

Misc features:

- Free EMS for personal purposes
- Bit handling routines, including read/set/reset/toggle bit, shift left and
  right
- Routines to find the color in any specified palette that best fits with the
  specified red, green and blue hues
- Useful routine to find the angle between any two given points
- Directory scanning routines, with support for Windows long filenames
- Fast multi-purpose records array sorting routine
- Internal high precision timer for framerate synchronization
- Error messaging system
- Datafiles decoding routines, with support for password-crypted data


-----------------------------------------------------------------------------
1.5 - Installing the library
-----------------------------------------------------------------------------

The DirectQB library is now shipped as a set of OBJ files, together with their
own assembly source codes. You should have these files into the library
directory:

MAIN.OBJ        - Holds main library functions and common variables
DRAW.OBJ        - Primitive drawing functions
IMAGE.OBJ       - Bsave/BMP/PCX image files handling
SPRITE.OBJ      - Special sprites drawing routines
BIT.OBJ         - Bit handling routines
PALETTE.OBJ     - Palette handling routines
FONT.OBJ        - Font functions
DISK.OBJ        - Disk and directory handling functions
BLENDING.OBJ    - Color blending support module
KEYBOARD.OBJ    - Custom keyboard handler routines
JOYSTICK.OBJ    - Joystick/joypad support module
MOUSE.OBJ       - Mouse handling routines
SOUND.OBJ       - Sound engine module
3D.OBJ          - Triangle drawing functions
DATAFILE.OBJ    - Datafile decoding routines

All these files together make the DirectQB library; we'll examine later how
to work with them. Additional files you must have in your DQB directory,
other than the ASM source files, are:

ERRORS.INC      - Include file used by MAIN.ASM; contains error messages
README.1ST      - Welcome message
FILELIST.TXT    - Complete list of all the files in the DirectQB package
DIRECTQB.DOC    - Library manual (this file)
DQBMAN.BAS      - DirectQB Library Manager utility
DQBMAN.MHL      - Help file for the library manager
DQBTOOLS.BAS    - Fonts and mouse cursors editor
SMALL.FNT       - Small font created with DQB Tools
HITECH.FNT      - Another font created with DQB Tools
SCRIPT.FNT      - Script font created with DQB Tools
DQBENC.BAS      - Datafile encoder program

So, what's up now? You need to create the LIB and QLB files to work with
DirectQB under QB 4.5... For this purpose, there's the DirectQB Library
Manager utility, which will guide you into this process. Run that program
now!

Once built, to load the quicklibrary run QB at the DOS prompt by typing:

QB/LDQB

The IDE will appear, and you'll be able to use the DirectQB functions.

DirectQB is made of several OBJ files, and this means you can link some of
them to create your own quicklibrary, depending on your needs. For example,
if you're not planning to use the sound engine, there's no need to include
the SOUND.OBJ file in the library... The library manager utility allows you
to select each of these DirectQB modules, and creates the following files
depending on your selections:

DQB.LIB         - Quicklibrary file to be linked to your executable programs
DQB.QLB         - Quicklibrary file to be used from inside the QB IDE
DIRECTQB.BI     - Include file for the DirectQB library

and

INSTALL.DAT     - Data on installed modules for library manager
INSTALL.LOG     - Installation log file
CALLS.BAS       - Used during the library building process, it can be deleted

For a list of the functions contained within each of the OBJ modules, take a
look at appendix F of this manual.


-----------------------------------------------------------------------------
1.6 - Basic concepts
-----------------------------------------------------------------------------

The DirectQB library makes an extensive use of the EMS memory to store off-
screen buffers, named "layers", plus sounds. A layers is basically a buffer
where you act as you do with the screen. You can draw pixels on it, as well as
using all the graphical functions of this library. The EMS memory is
automatically handled for you, so all you have to do when calling every
graphical function is to specify a layer where to act. To draw something
directly to the screen, just use layer number 0 (there's also a constant named
VIDEO, as specified into APPENDIX A). You can specify the number of layers to
allocate in EMS by calling the DQBinit function, as well as the number of
sounds to allocate space for (again in EMS) and the amount of free EMS to
preserve for your own purposes; DQBinit must be ALWAYS called before calling
any other function of this library, or you'll probably crash your system.
Remember also to call DQBclose just before ending your programs; this will
free previously allocated memory and it'll turn off the custom keyboard
handler and the sound engine if they were on (plus doing other tasks).
You can also avoid using EMS, by declaring up to 10 extra layers stored in
conventional memory. To setup these "base layers" refer to the DQBsetBaseLayer
function.

Other than this, you should also keep in mind the following things:

˛ To speed things up, a lot of checks are skipped, so for example if you
  initialize the library with 3 extra layers, DO NOT refer to layer -1 or 4!

˛ When referring to base layers, be sure you've previously set up them,
  because by drawing something onto a layer that has not be configured with
  the DQBsetBaseLayer function, you're probably going to crash your system.

˛ Every graphical function that draws something, except DQBbox, DQBboxf,
  DQBfPut and DQBfilterBox supports clipping; this means that every pixel that
  lies outside the current clipping box will not be drawn. Clipping box is set
  at startup (when calling DQBinit) to (0,0)-(319,199), and it can be changed
  at any time by calling the DQBsetClipBox function.

˛ The sprite data format for library get and many put routines is the same
  used by the standard GET and PUT statement; the advantage of using DirectQB
  functions is that they act on layers, they support clipping (except DQBfPut)
  and they're faster than GET and PUT...

˛ DQBxPut has the great advantage that it does not require you to store the
  sprites into an array and then to use this to draw it; this means you save
  extra memory for your application, but the bad thing is that DQBxPut is
  slower than normal DQBput, and it can handle only sprites with an height up
  to 50 pixels.

˛ The transparent color is color number 0 and cannot be changed.

˛ When calling a function that requires a box by passing the upper-left
  (x1,y1) and lower-right (x2,y2) corners, always remember that it must be
  x1<x2 and y1<y2, or you'll probably crash your system.

˛ By default, when calling DQBprint, the standard BIOS font is used. This can
  be changed by calling the DQBsetFont procedure; to restore the BIOS font,
  just call DQBsetBIOSfont.

˛ When referring to a color hue, the red, green and blue components must
  always be in the range 0-63, otherwise your system may crash.

˛ The blending functions all require a blender map. If a blender map has not
  been created by DQBcreateBMap, any calls to DQBsetBMap, DQBgetBMap,
  DQBloadBMap, DQBsaveBMap, DQBbPut or DQBfilterBox will do nothing; you can
  create up to 10 blender maps, and to create them, you'll need free base
  memory. See DQBcreateBMap for details.

˛ Blender maps can map up to 255 foreground color entries; I suggest you to
  leave color 0 unmapped, as it should always be used for transparency only.

˛ Creating a blender map is not an easy job. It depends on the current palette
  and, of course, on what are your needs. Once created, it is suggested that
  you store your blender map into a file, so that you can load it at any time,
  without having to repeat the often slooow process.

˛ The default collision detection method is the bounding box check.

˛ You cannot use a framerate lower than 18; lower values will be rounded to
  this number. Also, when calling the DQBsetFrameRate function, the system
  clock rate is altered, and some programs (like TSRs - SBMIDI for example)
  that use the system timer may not run properly.

˛ When the custom keyboard handler has been turned on by calling the
  DQBinstallKeyboard function, the standard QB functions that handle the
  keyboard should not be used, or you'll probably lock up your machine.
  These functions can be called again only after restoring the old keyboard
  handler by calling DQBremoveKeyboard.

˛ If you want to use the mouse, after calling DQBinit and entering the VGA
  mode, it is recommended that you call the DQBmouseReset function. This will
  set the default cursor shape and range.

˛ The mouse status (coordinates and buttons status) is automatically updated
  when you move it; you don't have to call any other function to update it.

˛ For the joystick it's different: before calling the DQBjoyMove and
  DQBjoyFire functions, you have to update the internal joystick variables
  by calling the DQBpollJoy function. This is a relatively slow operation,
  expecially if no joysticks are connected, so be warned.

˛ The sound engine still has limitations: it supports only 8-bit mono WAV
  files for now, and you need a sound card with a DSP 2.00 or better...

˛ Datafiles can store up to 256 objects; each object is referred by an unique
  ID string, and you can't use the same string for different objects.

˛ If you have problems decoding an object from a datafile, check your password
  first, then if it's correct, check if you referred to the right object, and
  if the action you're doing is valid (i.e. check if the image you're trying
  to decode isn't stored as a sound)

Well, I hope it's all.
One last thing: when coding your programs, remember to include this line at
the very beginning of your code:

'$INCLUDE:'DIRECTQB.BI'

This will include the file DIRECTQB.BI into your project; this file contains
function and constant declarations used by the library and is needed in order
to use it.


-----------------------------------------------------------------------------
1.7 - Limits of the library
-----------------------------------------------------------------------------

This library operates only in 320x200 with 256 colors video mode. I really
don't know if I'll ever release an hires/hicolor version; I have the knowledge
to do it, but this would require me to rewrite almost all the library...
About the sound engine, only 8-bit mono WAV files are supported for now, and
the sampling rate is limited to 22Khz. Why you ask? Well, adding support for
higher frequencies requires lot of extra code, and I don't think a game
requires so high-quality sounds; in addition, 16-bit sounds would require
twice the size to store them, so why bothering?
The routines are written thinking about speed, so a lot of range checks are
skipped; this is wanted, so don't get hangry if your computer crashes, if it
does so, it's due to you.
About the joystick, DirectQB can handle up to two joysticks with 2 buttons
each, OR only 1 joystick with 4 buttons. In addition, the routines are mainly
written to handle joypads, so they work great with them. Analog joysticks are
also supported, but the routines will let you know only if the joystick has
been moved into a direction, and not the exact axis positions.
Fonts can have a maximum size of 8x8 pixels; the height is the same for all
the characters, while the width can vary.
Datafiles are a valid alternative to having multiple small files in your game
directory: anyway compression is not the best (a simple RLE algorithm is used)
but it's really fast. The password and object id strings must have a length
of 8 characters maximum; you can also avoid to crypt your datafiles, by
specifying a null password.
For the various file formats used by DirectQB, I strongly suggest you to take
a look at appendix C.



=============================================================================
2.  FUNCTIONS REFERENCE
=============================================================================


Warning: all the example programs in this section have been tested with the
full library release, i.e. all the modules have been included. For efficiency
reasons you can remove unused modules at any time with the DQB library manager
program.


-----------------------------------------------------------------------------
DQBangle FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBangle(BYVAL x1,BYVAL y1,BYVAL x2,BYVAL y2)

Calling:

˛   x1          X coordinate of first point
˛   y1          Y coordinate of first point
˛   x2          X coordinate of second point
˛   y2          Y coordinate of second point

Returns:

An INTEGER value holding the angle between the two points, in the range 0-255


Description:

Do you ever wanted to know the angle an enemy should face to lock for the
player in your games? This function lets you know the exact angle between two
given points, i.e. what angle the object located at the first point should
face to "see" the second one. Returned angle is in the range 0-255, where 0
means the second point is above the first, 127 that it's below it, etc...

Notes:

As DQBangle returns the angle in the range 0-255, you can easily use this
function in conjunction with DQBrPut.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Allocates memory for a simple 32x32 pixels sprite
DIM Sprite(514)

' Let's initialize the library with one extra layer, no sounds nor free EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Checks if a mouse is available
IF NOT DQBmouseDetected THEN
    ' Mouse not found!
    PRINT "This example requires a mouse to run!"
    DQBclose
    END
END IF

DQBinitVGA
DQBclearLayer 1

' Draws our sprite and gets it from a hidden layer
DQBline 1, 15, 0, 22, 26, 40
DQBline 1, 15, 0, 8, 26, 40
DQBline 1, 8, 26, 22, 26, 40
DQBpaint 1, 16, 16, 4
DQBget 1, 0, 0, 31, 31, VARSEG(Sprite(0)), VARPTR(Sprite(0))

' Starts demo
DQBresetMouse
DQBmouseShow
DO
  ' Clears layer 1 for double buffering effect
  DQBclearLayer 1
  
  ' Finds angle between the center of our sprite and the mouse cursor
  a = DQBangle(160, 100, DQBmouseX, DQBmouseY)

  ' Draws rotated sprite
  DQBrPut 1, 144, 84, VARSEG(Sprite(0)), VARPTR(Sprite(0)), a, 100

  ' Updates the screen
  DQBwait 1
  DQBmouseHide
  DQBcopyLayer 1, VIDEO
  DQBmouseShow

  ' Ends demo if the user presses a key or any of the mouse buttons
  IF DQBmouseLB OR DQBmouseRB OR INKEY$ <> "" THEN EXIT DO
LOOP

' Ends the program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBasc FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBasc(BYVAL ScanCode,BYVAL ShiftFlag)

Calling:

˛   ScanCode    Scancode of the character
˛   ShiftFlag   See function description

Returns:

An INTEGER value holding the ascii code number of specified character


Description:

This function is used to retrieve the ascii code of a specified character,
when you know its scancode. The problem is that for each scancode there can
be one or two associated characters... For example, the "A" character is
associated to the scancode number 30, but also "a" is associated to 30;
DirectQB has two internal tables holding all the possible combinations, so
you must specify in which table to search for specified character. That's the
purpose of the ShiftFlag parameter: if true, in our example you'll get an "A",
otherwise an "a".

Notes:

This function can be called even if the keyboard handler is off.


Example:

none


-----------------------------------------------------------------------------
DQBbgtri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBbgtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL c1, BYVAL x2,
                      BYVAL y2, BYVAL c2, BYVAL x3, BYVAL y3, BYVAL c3)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   c1          color of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   c2          color of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   c3          color of the third vertex


Returns:

none


Description:

Draws a gouraud-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,
interpolating specified colors, using the current palette. Resulting colors
are finally blended with the background, using the current blender map.
DQBbgtri does not support transparency, but it's affected by the clipping box.

Notes:

Gouraud shading works better when you set a palette with lots of shades of the
same color; it is up to you to find the best settings for your needs. Remember
also to set an appropriate blender map to obtain best results; see also
DQBtri, DQBbtri, DQBttri


Example:

none


-----------------------------------------------------------------------------
DQBbox SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBbox (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                    BYVAL Col)

Calling:

˛   Layer       Layer where to draw the box
˛   x1          Upper left corner x coordinate
˛   y1          Upper left corner y coordinate
˛   x2          Lower right corner x coordinate
˛   y2          Lower right corner y coordinate
˛   Col         Drawing color

Returns:

none


Description:

Draws an empty box on the given layer, with (x1,y1) and (x2,y2) as the upper
left and lower right corners, with Col color.

Notes:

This function is not affected by the clipping box, and no range checks are
done, so pay attention. In addition, remember that it must be x1<x2 and y1<y2.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Draws a box on the screen
DQBbox VIDEO, 0, 0, 319, 199, 15

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends the program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBboxf SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBboxf (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                     BYVAL Col)

Calling:

˛   Layer       Layer where to draw the box
˛   x1          Upper left corner x coordinate
˛   y1          Upper left corner y coordinate
˛   x2          Lower right corner x coordinate
˛   y2          Lower right corner y coordinate
˛   Col         Drawing color

Returns:

none


Description:

Same as DQBbox, but draws a full box filled with Col color.

Notes:

See DQBbox.


Example:

See DQBbox example


-----------------------------------------------------------------------------
DQBbPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBbPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL BMap)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   BMap        Blender map to be used

Returns:

none


Description:

DQBbPut draws a sprite blending its colors with the background; the way the
colors are blended depends on the specified blender map. If the bmap has not
been created by calling DQBcreateBMap, this function does nothing. There are
virtually unlimited special color effects allowed by using the blender map
system: by setting up an appropriate bmap for your palette, you can obtain
a translucency effect for example.

Notes:

DQBbPut is affected by the clipping box, so pixels outside this box will not
be drawn; transparency is also supported. See also DQBcreateBMap, DQBsetBMap,
DQBgetBMap, DQBloadBMap, DQBsaveBMap, DQBput, DQBfPut, DQBsPut and DQBrPut.

Example:

*****************************************************************************

' Use integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Let's initialize the library
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Releases 256 bytes from the far heap to allow DQBcreateBMap to allocate
' conventional memory for the blender map; we're going to map one color only,
' so we need 1*256=256 bytes to create the blender map
dummy& = SETMEM(-256)

' Let's build blender map 1, mapping color 40 only
IF DQBcreateBMap(1, 40, 40) THEN DQBclose: PRINT DQBerror$: END

' Here we set our only color combination on bmap number 1: if a pixel of
' color 40 (bright red) is drawn over another of color 32 (bright blue), the
' pixel is drawn with color 13 (bright purple)
DQBsetBMap 1, 40, 32, 13

' Let's dimension our two sprites using DQBsize
size = DQBsize(0, 0, 63, 7)
DIM Sprite(size)

DQBclearLayer 1
DQBprint 1, "DirectQB", 0, 0, 32
DQBprint 1, "Power!", 0, 8, 40

' Get our sprites
DQBget 1, 0, 0, 63, 7, VARSEG(Sprite(0)), VARPTR(Sprite(0))
DQBget 1, 0, 8, 63, 15, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + size)

DQBinitVGA

' Let's begin the demo
FOR x = -64 TO 320
  ' Clean our hidden layer
  DQBclearLayer 1

  ' Draws our sprites on layer 1
  DQBput 1, x, 96, VARSEG(Sprite(0)), VARPTR(Sprite(0))
  DQBbPut 1, (256 - x), 96, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + size), 1

  ' Copies layer 1 on the screen
  DQBwait 3
  DQBcopyLayer 1, VIDEO
NEXT x

' Ends program
DQBclose
dummy& = SETMEM(256)

*****************************************************************************


-----------------------------------------------------------------------------
DQBbtri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBbtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                     BYVAL x3, BYVAL y3, BYVAL Col, BYVAL BMap)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   Col         color
˛   BMap        Blender map to be used


Returns:

none


Description:

Draws a triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex, and fills it
by blending specified color with the background, using the specified blender
map. This function does not support transparency, but it's affected by the
clipping box.

Notes:

See also DQBtri, DQBgtri, DQBttri


Example:

none


-----------------------------------------------------------------------------
DQBbttri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBbttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                      BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,
                      BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,
                      BYVAL TextureOff, BYVAL BMap)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   u1          x coordinate of first vertex on texture
˛   v1          y coordinate of first vertex on texture
˛   u1          x coordinate of second vertex on texture
˛   v1          y coordinate of second vertex on texture
˛   u1          x coordinate of third vertex on texture
˛   v1          y coordinate of third vertex on texture
˛   TextureSeg  Array segment holding the texture (use VARSEG)
˛   TextureOff  Array offset holding the texture (use VARPTR)
˛   BMap        Blender map to be used


Returns:

none


Description:

Draws a texture-mapped triangle with (x1,y1), (x2,y2) and (x3,y3) as vertexes.
This function works exactly like DQBttri, but colors are blended with the
background by using the specified blender map.

Notes:

See also DQBttri, DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri


Example:

none


-----------------------------------------------------------------------------
DQBchDir FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBchDir (NewDir AS STRING)

Calling:

˛   NewDir      New directory

Returns:

0 if the operation is successful, otherwise -1


Description:

This function changes the current directory to the new specified one; you can
also use Windows long directory names.

Notes:

The main difference between the standard QB statement CHDIR is that this
function works also with Windows long filenames, while the first doesn't.


Example:

none


-----------------------------------------------------------------------------
DQBclearLayer SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBclearLayer (BYVAL Layer)

Calling:

˛   Layer       Layer to clear

Returns:

none


Description:

Clears the contents of a given layer: all the pixels are set to color 0. This
function is automatically called for all the allocated layers when calling
DQBinit.

Notes:

None


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

PRINT "Press a key to clear the screen!"
WHILE INKEY$="":WEND

' Clears the screen
DQBclearLayer VIDEO

' Ends the program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBclose SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBclose ()

Calling:

none

Returns:

none


Description:

This function deallocates the EMS memory used by the layers initialized by
DQBinit, turns off the keyboard interrupt handler and the sound engine if
they were on; it also deallocates the blender maps if they were created, and
does other closing stuff you may have forgot.
DQBclose must always be called before ending your programs, otherwise
allocated EMS memory will be lost, and you'll have to reboot your computer to
free it.

Notes:

If already in graphics mode, this function also automatically switches the
screen to plain text mode, so you don't have to worry about calling
DQBinitText before it. See also DQBinit.


Example:

none


-----------------------------------------------------------------------------
DQBcloseDataFile SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcloseDataFile ()

Calling:

none

Returns:

none


Description:

Close opened datafile; if no datafile was opened, this function does nothing.

Notes:

You cannot have more than an opened datafile at the same time, so this
function may be useful when you have your data stored in different datafiles.
This function is automatically called by DQBclose; see also DQBopenDataFile.


Example:

See DQBopenDataFile example


-----------------------------------------------------------------------------
DQBcloseFLI SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcloseFLI ()

Calling:

none

Returns:

none


Description:

Closes a FLI file that was previously opened with the DQBopenFLI function.
You must close a FLI file with this function before attempting to open another
one, otherwise you'll get an error, as DirectQB can handle only one opened
FLI animation at a time. If no FLIs were opened, this function does nothing.

Notes:

This function is meant to be used only in conjunction with DQBopenFLI and
DQBplayFLIstep. If you're going to play a whole FLI animation as is by calling
DQBplayFLI, there's no need to call also this function when the animation
ends. DQBclose automatically calls this function.


Example:

See DQBplayFLIstep example


-----------------------------------------------------------------------------
DQBcollide FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcollide (BYVAL x1, BYVAL y1, BYVAL Seg1, BYVAL Off1, BYVAL x2,
                        BYVAL y2, BYVAL Seg2, BYVAL Off2)

Calling:

˛   x1          x position of first sprite
˛   y1          y position of first sprite
˛   Seg1        Segment of first sprite array (use VARSEG)
˛   Off1        Offset of first sprite array (use VARPTR)
˛   x2          x position of second sprite
˛   y2          y position of second sprite
˛   Seg2        Segment of second sprite array (use VARSEG)
˛   Off2        Offset of second sprite array (use VARPTR)

Returns:

True if the sprites collide, otherwise false


Description:

Given two sprites, this function tests for them to collide, using current
check method. There are two collision detection methods available: bounding
box check and pixel-perfect check. Needless to say, the first is the fastest,
but the other gives you a perfect collision precision.

Notes:

By default, the collision detection method is the bounding box check; you can
change this at any time by calling DQBsetCollideMethod.


Example:

none


-----------------------------------------------------------------------------
DQBcollideOnLayer FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcollideOnLayer (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                               BYVAL SpriteOff)

Calling:

˛   Layer       Layer where to test for collision(s)
˛   x           x position of sprite
˛   y           y position of sprite
˛   SpriteSeg   Segment of sprite array (use VARSEG)
˛   SpriteOff   Offset of sprite array (use VARPTR)

Returns:

Pixel color of first colliding object, 0 on no collisions


Description:

This function introduces the concept of "collisions layer": by using it, you
can achieve fast collision detections between several sprites, in an easy way.
By specifying a layer, and a sprite position and data, DQBcollideOnLayer
returns the color of the first non-trasparent pixel on the layer, that
actually collides with the specified sprite. If no collision is detected, 0
is returned.

Notes:

Sprite position can be inside as well as outside layer space (i.e. clipping
is supported); It is suggested that you use DQBhPut to draw all your active
sprites on the collision layer, so you can easily check for collisions using
this function.


Example:

none


-----------------------------------------------------------------------------
DQBcopyBlendLayer SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcopyBlendLayer (BYVAL SourceLayer, BYVAL DestLayer, BYVAL BMap)

Calling:

˛   SourceLayer   Source layer to copy data from
˛   DestLayer     Destination layer where to copy data
˛   BMap          Blender map to be used

Returns:

none


Description:

Copies the contents of SourceLayer and blends them into DestLayer, using
specified blender map.

Notes:

See also DQBcopyLayer, as this function works almost the same way


Example:

none


-----------------------------------------------------------------------------
DQBcopyHitLayer SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcopyHitLayer (BYVAL SourceLayer, BYVAL DestLayer, BYVAL Col)

Calling:

˛   SourceLayer   Source layer to copy data from
˛   DestLayer     Destination layer where to copy data
˛   Col           Filling color

Returns:

none


Description:

Works exactly like DQBcopyLayer, except for the fact than all the non-0 pixels
of the source layer are drawn onto the destination layer with the same color
specified with the "Col" parameter.

Notes:

Useful to create collision layers, to be used in conjunction with the
DQBcollideOnLayer function.


Example:

none


-----------------------------------------------------------------------------
DQBcopyLayer SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcopyLayer (BYVAL SourceLayer, BYVAL DestLayer)

Calling:

˛   SourceLayer   Source layer to copy data from
˛   DestLayer     Destination layer where to copy data

Returns:

none


Description:

Copies the contents of SourceLayer into DestLayer. All the data previously
into DestLayer will be lost. This function can be used to create double
buffered animations; just draw every sprite onto a layer on EMS, and then use
DQBcopyLayer to copy its contents to the screen.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds
IF DQBinit(1, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Draws a box on the hidden layer
DQBbox 1, 0, 0, 319, 199, 15

' Copies the hidden layer on the screen
DQBcopyLayer 1, VIDEO

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBcopyTransLayer SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBcopyTransLayer (BYVAL SourceLayer, BYVAL DestLayer)

Calling:

˛   SourceLayer   Source layer to copy data from
˛   DestLayer     Destination layer where to copy data

Returns:

none


Description:

This function is similar to DQBcopyLayer, but the pixels with color 0 of the
source layer are skipped and not copied onto the destination layer; this
allows transparent layer copy. With some practice, it is possible to obtain
a parallax scrolling effect using this function with DQBscroll.

Notes:

Needless to say, DQBcopyTransLayer is slower than DQBcopyLayer, be warned.


Example:

See DQBcopyLayer example


-----------------------------------------------------------------------------
DQBcreateBMap FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBcreateBMap (BYVAL BMap, BYVAL FirstCol, BYVAL LastCol)

Calling:

˛   BMap          Code number of the blender map to create
˛   FirstCol      First foreground color to map
˛   LastCol       Last foreground color to map

Returns:

An INTEGER value holding the operation result:

>   0     Blender map successfully created and initialized
>   1     Not enough free conventional memory
>   2     Blender map already created


Description:

This function attempts to create a blender map in *conventional* memory; this
requires as much memory as much foreground colors you map. A blender map is a
table with all the possible color combinations between the specified
foreground colors and the 256 background colors; so this is the formula to
obtain the amount of memory needed to create a bmap:

                        (LastCol - FirstCol + 1) * 256

The fore color is the color of each pixel of your sprite, and the back color
is the one of each pixel of the background layer where you're drawing. Suppose
you have a palette with color 1 as bright red, color 2 as bright green, and
color 3 as bright purple. Well, you could call DQBsetBMap 7,1,2,3: this way
every time you use DQBbPut referring to bmap number 7 to draw a sprite with
some pixels of color 1, and the background is filled with color 2, you'll see
a cyan sprite (i.e. drawn with color 3)...
It's a hard thing to explain, but once you've understood it, you'll also
understand the system offers virtually any special effect, depending on your
palette and, of course, on the blender map you set.

Notes:

So you have to set your blender map on your needs: as it's often a slow
process, there're the DQBsaveBMap and DQBloadBMap functions that help you.
It is also suggested that you use DQBfindCol to create your blender map
independently from the current palette. Keep also in mind that any blending
function will not work unless the blender map has not been created by calling
DQBcreateBMap, and remember that to gain more free base memory you should
always call the QB function SETMEM before calling it; another important thing
to remember is that a bmap can have up to 255 foreground colors mapped: do
not try to create a bmap of 256 elements, as you may end up with unpredictable
results. Here I suggest you to leave color 0 unmapped, as it should always be
used for transparencies only. See also DQBsetBMap, DQBgetBMap, DQBloadBMap,
DQBsaveBMap, DQBbPut, DQBfilterBox.


Example:

See DQBbPut example


-----------------------------------------------------------------------------
DQBdir$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBdir$ (Mask AS STRING, Attrib AS INTEGER)

Calling:

˛   Mask          Mask for file(s) to search for
˛   Attrib        Attributes of the file(s) to search for

Returns:

A STRING holding the filename of the next file found


Description:

DQBdir scans the directory for the files matching specified mask; the mask
can include full path and wildcards, and you can also use Windows long
filenames. If no files are found, the function returns a null string. The
first time DQBdir is called with a mask, it searches for the first file
matching it; if a file is found, then you can continue to scan the directory
by calling this function again, but by passing a null string as mask. Repeat
this process until you get a null string, and you'll obtain a full directory
scan. The attrib parameter specifies which kind of files to search for: there
are constants made up for you, which you can also sum to search for a larger
variety of files (for example, to search simultaneously for normal archive
files and directories), so just take a look at appendix A for them.

Notes:

A hint: you can determine if a file exists by simply checking if DQBdir$ of
that file as mask, with ATTRIB.A as attribute, gives a null string or the
file name itself...
See also DQBdrive$, DQBpath$, DQBnumDrives, DQBsetDrive, DQBchDir


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

CLS

' Prints available drives
PRINT "Available drives: ";
FOR i = 1 TO DQBnumDrives
  PRINT "[" + CHR$(64 + i) + "] ";
NEXT i
PRINT

' Prints volume label
PRINT "Current volume label is " + DQBdir$("*.*",ATTRIB.L)

' Prints current drive and directory
PRINT "Directory of " + DQBdrive$ + ":\" + DQBpath$

' Let's search for normal archive ".BAS" files
File$ = DQBdir$("*.BAS", ATTRIB.A)
IF File$ = "" THEN
  ' No files matching
  PRINT "No .BAS files found!"
ELSE
  ' A first file was found! Let's print it
  PRINT File$

  ' Now we search for the next files... if any
  DO
    ' This second time we don't need the mask nor the attributes
    File$ = DQBdir$("",0)

    ' If no more files are found, then exit the loop
    IF File$ = "" THEN EXIT DO

    ' Prints our next file
    PRINT File$
  LOOP
END IF

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBdrive$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBdrive$ ()

Calling:

none

Returns:

The drive letter character


Description:

This function simply returns a string of 1 character holding the current
drive letter.

Notes:

See also DQBsetDrive, DQBnumDrives, DQBchDir, DQBdir$, DQBpath$


Example:

See DQBdir$ example


-----------------------------------------------------------------------------
DQBellipse SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBellipse (BYVAL Layer, BYVAL x, BYVAL y, BYVAL rx, BYVAL ry,
                        BYVAL Col)

Calling:

˛   Layer         Source layer to copy data from
˛   x             x coordinate of the center of your ellipse
˛   y             y coordinate of the center of your ellipse
˛   rx            Horizontal radius in pixels
˛   ry            Vertical radius in pixels
˛   Col           Ellipse color

Returns:

none


Description:

This function is useful to draw ellipses (and, needless to say, a circle is
a particular ellipse with equal radiuses); the radiuses can range from 0 up
to 256.

Notes:

Also DQBellipse is affected by the clipping box


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

FOR i = 10 TO 90 STEP 10
  ' Draws our ellipses
  DQBellipse VIDEO, 160, 100, 90, i, 40
  DQBellipse VIDEO, 160, 100, i, 90, 40
NEXT i

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBerror$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBerror$ ()

Calling:

none

Returns:

A STRING holding the last error message


Description:

With this DQBerror$, you do not need to check for every unsuccessfull result
of your DQB function calls anymore: when something goes wrong, DQBerror$
automatically holds a short error message that explains what went wrong.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with one extra layer and one sound, but no EMS
IF DQBinit(1, 1, 0) THEN DQBclose: PRINT DQBerror$: END

' If we get here, no errors have occured
PRINT "DirectQB successfully initialized!"

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBfadeIn SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfadeIn (Pal AS STRING)

Calling:

˛   Pal         A string of 768 characters holding the palette to fade into

Returns:

none


Description:

Fades the current palette into the given one; current palette may be
completely different from the target one. The Pal string can be obtained by
calling the DQBgetPal or the DQBloadImage functions, or it can be set
manually; just keep in mind that there're three bytes for each color,
representing the red, green and blue components of them, in the range 0-63.

Notes:

See also DQBfadeTo, DQBgetPal, DQBsetPal, DQBpalOff, DQBgetCol, DQBsetCol


Example:

See DQBfadeTo example


-----------------------------------------------------------------------------
DQBfadeStepIn SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfadeStepIn (Pal AS STRING)

Calling:

˛   Pal         A string of 768 characters holding the palette to fade into

Returns:

none


Description:

Works exactly like DQBfadeIn, but this will only fade all the colors by a
single step. To be sure of fading all your colors to the new palette, you
should call this function 64 times repeatedly. DQBfadeStepIn can be useful to
move your stuff around while fading.

Notes:

See also DQBfadeIn


Example:

none


-----------------------------------------------------------------------------
DQBfadeStepTo SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfadeStepTo (BYVAL Red, BYVAL Green, BYVAL Blue)

Calling:

˛   Red         Red hue to fade colors into
˛   Green       Green hue to fade colors into
˛   Blue        Blue hue to fade colors into

Returns:

none


Description:

Works exactly like DQBfadeTo, but this function will only fade all the colors
by a single step. As with DQBfadeStepIn, to be sure to fade all your palette,
you should call this function 64 times. DQBfadeStepTo can be useful to move
your stuff around while fading.

Notes:

See also DQBfadeTo


Example:

none


-----------------------------------------------------------------------------
DQBfadeTo SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfadeTo (BYVAL Red, BYVAL Green, BYVAL Blue)

Calling:

˛   Red         Red hue to fade colors into
˛   Green       Green hue to fade colors into
˛   Blue        Blue hue to fade colors into

Returns:

none


Description:

Fades all the colors in current palette to the specified red, green and blue
hues. To fade a palette to black, just call this function with 0,0,0 as
parameters; it's quite powerful, as it can fades any palette to any specified
color.

Notes:

See also DQBfadeIn, DQBgetPal, DQBsetPal, DQBpalOff, DQBgetCol, DQBsetCol


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

DIM Pal AS STRING * 768

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Stores the default palette into Pal
DQBgetPal Pal

' Turns all the colors to black
DQBpalOff

' Draws randomly 500 pixels on the screen
FOR i = 1 TO 500
    RANDOMIZE TIMER
    DQBpset VIDEO, (RND*320), (RND*200), (RND*256)
NEXT i

' Fades the palette into the original one
DQBfadeIn Pal

' Fades the palette to white
DQBfadeTo 63, 63, 63

' and then to black
DQBfadeTo 0,0,0

' Restores the original palette
DQBsetPal Pal

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBfilterBox SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfilterBox (BYVAL Layer, BYVAL x1, BYVAL y2, BYVAL x2, BYVAL y2,
                          BYVAL Col, BYVAL BMap)

Calling:

˛   Layer       Layer where to draw the filter box
˛   x1          Upper left corner x coordinate
˛   y1          Upper left corner y coordinate
˛   x2          Lower right corner x coordinate
˛   y2          Lower right corner y coordinate
˛   Col         Filter color
˛   BMap        Blender map to be used

Returns:

none


Description:

DQBfilterBox draws a full box blending specified color with the background,
using the given blender map; if the blender map has not been created, this
function will not draw the box.

Notes:

The filter color acts as the fore color; it's up to you to set an appropriate
blender map. Remember also that it must be x2>=x1 and y2>=y1. See also
DQBcreateBMap, DQBloadBMap, DQBsaveBMap, DQBsetBMap, DQBgetBMap and DQBbPut.


Example:

none


-----------------------------------------------------------------------------
DQBfindCol FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBfindCol (BYVAL Red, BYVAL Green, BYVAL Blue)

Calling:

˛   Red         Red hue of the color to find
˛   Green       Green hue of the color to find
˛   Blue        Blue hue of the color to find

Returns:

An INTEGER value ranging 0-255, holding the index of the color found


Description:

DQBfindCol searches the current palette for the color that best fits with the
specified red, green and blue hues. It can be really useful to create a
blender map in conjunction with the DQBsetBMap routine.

Notes:

This function may return bad results, depending on the current palette and
the specified hues, so use it with caution. As it scans the palette, you'll
see the screen flickering a little during each call to this function; to
avoid this, you can use the DQBfindPalCol, that allows to search for a color
into any specified palette.


Example:

none

-----------------------------------------------------------------------------
DQBfindPalCol FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBfindPalCol (Pal AS STRING, Red AS INTEGER,
                                Green AS INTEGER, Blue AS INTEGER)

Calling:

˛   Pal         Palette to scan
˛   Red         Red hue of the color to find
˛   Green       Green hue of the color to find
˛   Blue        Blue hue of the color to find

Returns:

An INTEGER value ranging 0-255, holding the index of the color found


Description:

This function works exactly like DQBfindCol, except for the fact that this one
searches for a color into a specified palette, not necessarly on the current
one. This also avoids the bad looking flickering of the DQBfindCol function.
The palette should be get by the DQBgetPal, DQBloadLayer or similar routines
that use the standard DirectQB palette format (see appendix C for details).

Notes:

See also DQBfindCol


Example:

none


-----------------------------------------------------------------------------
DQBfPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR

Returns:

none


Description:

Like DQBput, DQBfPut draws a sprite on specified layer, but using a faster
algorithm. This function does not allow clipping nor transparency, and works
better with big sprites with a width which is a multiple of 4.

Notes:

See DQBput, DQBsPut, DQBrPut and DQBbPut


Example:

See DQBput example


-----------------------------------------------------------------------------
DQBframeReady FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBframeReady ()

Calling:

none

Returns:

True if enough time has passed to synchronize graphics, otherwise false


Description:

DQBframeReady is to be used in conjunction with DQBsetFrameRate to synchronize
your graphics with a specified framerate. Once you set the FPS rate with
DQBsetFrameRate, you should wait before displaying each frame, until this
function returns true.

Notes:

See DQBsetFrameRate


Example:

none


-----------------------------------------------------------------------------
DQBfttri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBfttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                      BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,
                      BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,
                      BYVAL TextureOff)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   u1          x coordinate of first vertex on texture
˛   v1          y coordinate of first vertex on texture
˛   u2          x coordinate of second vertex on texture
˛   v2          y coordinate of second vertex on texture
˛   u3          x coordinate of third vertex on texture
˛   v3          y coordinate of third vertex on texture
˛   TextureSeg  Array segment holding the texture (use VARSEG)
˛   TextureOff  Array offset holding the texture (use VARPTR)


Returns:

none


Description:

Works exactly like normal DQBttri, but applies bilinear filtering during the
texturing process. This function is slower than DQBttri, but it draws better
looking triangles; anyway you need a gradient palette in order to achieve
good results.

Notes:

As this function has been coded thinking about speed, it isn't too accurate
with its calculations; this means that to be sure your triangle will be drawn
correctly, you should use a gradient palette set in the way that at least 4
or 5 colors are NOT used by your texture before and after its colors range.
I mean that if your texture uses only color 5 to 100, you also need to set
colors 0-4 and 101-105; this way you'll avoid boring problems... See also
DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri, DQBttri


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'
DIM texture(2049)

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Creates a red gradient palette
FOR i = 0 TO 63
  DQBsetCol i, i, 0, 0
  DQBsetCol 64 + i, 63, i, i
NEXT i

' Creates a texture filled with random red pixels
FOR x = 0 TO 63
  FOR y = 0 TO 63
    DQBpset VIDEO, x, y, 5 + (RND * 118)
  NEXT y
NEXT x
DQBbox VIDEO, 0, 0, 63, 63, 127
DQBline VIDEO, 63, 0, 0, 63, 127

' Gets the texture
DQBget VIDEO, 0, 0, 63, 63, VARSEG(texture(0)), VARPTR(texture(0))

' Clears the screen
DQBclearLayer VIDEO

' Draws 500 random triangles
FOR i = 1 TO 500
  RANDOMIZE TIMER
  DQBfttri VIDEO, RND * 320, RND * 200, RND * 320, RND * 200, RND * 320, RND * 200, 0, 0, 63, 0, 0, 63, VARSEG(texture(0)), VARPTR(texture(0))
NEXT i

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBget SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBget (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                    BYVAL SpriteSeg, BYVAL SpriteOff)

Calling:

˛   Layer       Layer where to get the sprite
˛   x1          Upper left corner x coordinate
˛   y1          Upper left corner y coordinate
˛   x2          Lower right corner x coordinate
˛   y2          Lower right corner y coordinate
˛   SpriteSeg   Segment of the array where to store the sprite; use VARSEG
˛   SpriteOff   Offset of the array where to store the sprite; use VARPTR

Returns:

none


Description:

Gets a sprite from the given layer in the box (x1,y1)-(x2,y2) and places the
data into specified array. Array must be dimensioned as (((Width*Height)*2)+4)
INTEGERs; you can use the DQBsize function and divide the result by 2 to
retrieve the size of your array without worring about this formula. Sprites
get with DQBget can be then used by DQBput to create animations.

Notes:

DQBget is not affected by the clipping box. Also, it must be x1<x2 and y1<y2.
This routine is optimized if your sprite width is a multiple of 4 or 2.
Several sprites can be stored into the same array; just pass the sprite with
a different index. In addition, the format of DQBget and DQBput is compatible
with the one of GET and PUT, so you can use them with the same sprite arrays.
See also DQBfPut, DQBsPut, DQBrPut and DQBbPut

Example:

See DQBput example


-----------------------------------------------------------------------------
DQBgetBMap FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBgetBMap (BYVAL BMap, BYVAL ForeCol, BYVAL BackCol)

Calling:

˛   BMap        Blender map to get color info from
˛   ForeCol     Foreground color
˛   BackCol     Background color

Returns:

An INTEGER value holding the color set for the specified combination in the
specified blender map


Description:

Returns the color set on the specified blender map for the color combination
given by the specified foreground and background colors. If the foreground
color is not mapped into the blender map, this function returns unpredictable
results, so pay attention.

Notes:

See also DQBcreateBMap and DQBsetBMap


Example:

none


-----------------------------------------------------------------------------
DQBgetCol SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBgetCol (BYVAL Col, Red, Green, Blue)

Calling:

˛   Col         Color index to retrieve data from
˛   Red         INTEGER variable where to store the red hue
˛   Green       INTEGER variable where to store the green hue
˛   Blue        INTEGER variable where to store the blue hue

Returns:

none


Description:

Gets the red, green and blue hues of the given color and stores them into the
Red, Green and Blue INTEGER variables. Hues ranges from 0-63.

Notes:

See also DQBsetCol


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'
DIM r, g, b

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Gets the hues for color 2 (dark green in default BIOS palette)
DQBgetCol 2, r, g, b

PRINT "Color 2 hues:"
PRINT "Red:", r
PRINT "Green:", g
PRINT "Blue:", b

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBgetPal SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBgetPal (Pal AS STRING)

Calling:

˛   Pal         String of 768 character where to store the palette

Returns:

none


Description:

Gets the current palette and stores it into the Pal string. Such a palette
can be then used by the DQBsetPal, DQBfadeIn and DQBsaveLayer functions.

Notes:

See appendix A to know how the palette is stored into the string


Example:

See DQBfadeTo example


-----------------------------------------------------------------------------
DQBgline SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBgetPal (Layer AS INTEGER, x1 AS INTEGER, y1 AS INTEGER, x2 AS
                       INTEGER, y2 AS INTEGER, Col1 AS INTEGER, Col2 AS
                       INTEGER)

Calling:

˛   Layer       Layer to draw the line onto
˛   x1          First endpoint x coordinate
˛   y1          First endpoint y coordinate
˛   x2          Second endpoint x coordinate
˛   y2          Second endpoint y coordinate
˛   Col1        First endpoint color
˛   Col2        Second endpoint color


Returns:

none


Description:

Like normal DQBline, this function draws a line onto the specified layer, but
interpolating colors between the two indexes specified at the endpoints; it
is recommended that you call this function only after setting up a proper
gradient palette.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBgtri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBgtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL c1, BYVAL x2,
                     BYVAL y2, BYVAL c2, BYVAL x3, BYVAL y3, BYVAL c3)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   c1          color of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   c2          color of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   c3          color of the third vertex


Returns:

none


Description:

Draws a gouraud-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,
interpolating specified colors, using the current palette. DQBgtri does not
support transparency, but it's affected by the clipping box.

Notes:

Gouraud shading works better when you set a palette with lots of shades of the
same color; it is up to you to find the best settings for your needs. See also
DQBtri, DQBbtri, DQBttri


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Sets up the palette with shades of red
FOR i = 0 TO 63
  DQBsetCol i, i, 0, 0
  DQBsetCol 64 + i, 63, i, i
NEXT i

' Draws 500 gouraud-shaded triangles; uses only the first 128 colors we set
FOR i = 1 TO 500
  DQBgtri VIDEO, (RND * 320), (RND * 200), (RND * 128), (RND * 320), (RND * 200), (RND * 128), (RND * 320), (RND * 200), (RND * 128)
NEXT i

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBhPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBhPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL Col)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   Col         Drawing color

Returns:

none


Description:

This function works exactly like normal DQBput, but it draws the whole sprite
using the same specified color, despite its original colors. It supports
clipping, but doesn't allow solid put mode; color 0 is always treated as
the transparent color.

Notes:

See also DQBput


Example:

none


-----------------------------------------------------------------------------
DQBid$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBid$ ()

Calling:

none

Returns:

none


Description:

Returns a small string that contains the library version and my name, in case
you want to display them somewhere in your credits section.

Notes:

You can use DQBver to retrive the library version only


Example:

See DQBver example


-----------------------------------------------------------------------------
DQBinit FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBinit (BYVAL NumLayers, BYVAL NumSounds, BYVAL MemSize)

Calling:

˛   NumLayers   Number of layers to allocate memory for
˛   NumSounds   Number of sounds to allocate memory for
˛   MemSize     Kbytes of EMS memory to preserve for custom purposes

Returns:

An INTEGER value holding the initialization result. It can be:

>   0     Initialization successful
>   1     386 or better CPU not detected
>   2     Unable to find an expanded memory manager
>   3     Not enough free EMS memory to allocate specified number of layers
>   4     Library has already been initialized


Description:

The DQBinit function must be called before any of the other library functions.
It allocates a specified number of layers, sounds and free memory into EMS,
and does other initializations; remember that you can allocate as much layers
as you want, and up to 256 sounds, as long as enough free memory is available,
otherwise you'll get an error 3 when calling this function; the same goes for
the amount of EMS for personal purposes: the limit is the amount of free EMS
available on your system.
The only thing you need to know is that each layer or sound takes 64KB of EMS.
Also, please keep in mind that if you refer to a layer or a sound number that
has not been allocated with this procedure, your system will probably crash:
I mean that if you allocate 3 layers with DQBinit, you must not refer to layer
4. If you get an error 2, please refer to section 1.3 of this manual, that
explains how to install EMS on your system.

Notes:

As DQBinit must be called at the beginning of your program, remember to call
DQBclose at its end. Initialized layers are automatically cleared (they're
filled with pixel color 0), and the sounds are reset to silence and 0 length.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with four extra layers and no sounds nor EMS
Result = DQBinit(4, 0, 0)

' Closes DirectQB
DQBclose

' A smarter way to handle errors would be to use DQBerror$, but for clarity
' here we do it this way:
SELECT CASE Result
CASE 0
    PRINT "Initialization successful"
CASE 1
    PRINT "Error: 386 or better CPU not detected!"
CASE 2
    PRINT "Error: unable to find an expanded memory manager!"
CASE 3
    PRINT "Error: not enough free EMS memory!"
END SELECT

' Ends program
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBinitText SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBinitText()

Calling:

none


Returns:

none


Description:

Initializes plain 80x25 text mode (mode 03h).

Notes:

By using this function instead of SCREEN 0, you can obtain smaller executables
once you compile your programs. See also DQBinitVGA


Example:

none


-----------------------------------------------------------------------------
DQBinitVGA SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBinitVGA()

Calling:

none


Returns:

none


Description:

Initializes 320x200 with 256 colors VGA video mode (mode 013h), and resets
the mouse if it was found.

Notes:

By using this function instead of SCREEN 13, you can obtain smaller executables
once you compile your programs. See also DQBinitText


Example:

none


-----------------------------------------------------------------------------
DQBinkey$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBinkey$ ()

Calling:

none

Returns:

If a key is pressed, it returns its character, otherwise a null string


Description:

DQBinkey$ works just like the usual INKEY$ QB statement. If any key is being
pressed, this function returns its associated character, otherwise it returns
a null string.

Notes:

This function works only while the custom keyboard handler is on, otherwise
you'll probably crash your system. In addition, as DQBinkey$ does not get the
character from the standard keyboard buffer, you'll loose your character if
you do not store it in some variable.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Installs the keyboard handler
DQBinstallKeyboard

' Let's prompt the user for a question
PRINT "Press 'Y' if you like DirectQB, otherwise 'N'"
DO
  DO: k$ = DQBinkey$: LOOP WHILE k$ = ""
  SELECT CASE k$
  CASE "Y": PRINT "Thank you!": EXIT DO
  CASE "N": PRINT "Too bad!!": EXIT DO
LOOP

' Waits for the user to press a key
DQBwaitKey KEYANY

' Removes the keyboard handler
DQBremoveKeyboard

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBinstallKeyboard SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBinstallKeyboard ()

Calling:

none

Returns:

none


Description:

Installs a custom keyboard interrupt handler that allows you to detect the
exact state (pressed or released) of any key at any time. Once activated by
calling this function, the standard QB routines like INPUT, INKEY$ or whatever
other routine that uses the keyboard as input, will be unavailable. Calling
them will probably result into your machine to crash, so pay attention. These
standard routines can be called only when the interrupt handler will be
uninstalled by calling DQBremoveKeyboard; this last function is automatically
called by DQBclose, so usually you don't have to bother about it. When the
handler is active, you can know the state of each key by simply calling the
DQBkey function.

Notes:

none


Example:

See DQBkey example


-----------------------------------------------------------------------------
DQBinstallSB FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBinstallSB (BYVAL VolActive, BYVAL Voices, BYVAL Freq,
                               BYVAL BaseAddr, BYVAL IRQ, BYVAL DMA)

Calling:

˛   VolActive   True to preserve base memory for the voices volume table
˛   Voices      Number of voices to mix at real-time
˛   Freq        Sampling rate
˛   BaseAddr    Base address of your soundcard
˛   IRQ         IRQ number setting
˛   DMA         Low DMA channel to be used

Returns:

An INTEGER value holding the initialization result. It can be:

>   0     Initialization successful
>   1     No sounds were allocated by DQBinit
>   2     Soundcard not found or DSP failed to reset
>   3     Old soundcard not supported
>   4     Specified DMA channel is not supported
>   5     Autodetection failed as the BLASTER variable is not set
>   6     High mixing speed not supported
>   7     Not enough memory to create the volume table


Description:

DQBinstallSB installs a custom IRQ routine and starts the sound engine if all
goes ok. If you don't know your sound settings (base address, IRQ or DMA), you
can pass the AUTO constant as the missing parameter(s); this will force the
function to search the BLASTER environmental variable (if available) for the
right setting. The number of voices can range from 1 up to 32, and tells the
sound engine how many digital sound channels to mix at real-time; needless to
say, on older computers, too many voices will slow down your programs...
The sampling rate may range from 4000 Hz up to 23000 Hz. If you specify true
as the VolActive parameter, you'll need 16K of base memory, as the function
will build an internal volume table, that will allow you to set custom volume
settings to each of the initialized voices; if you don't need to play sounds
with different volumes at the same time, you don't need this table, so just
pass false to this function.

Notes:

As always, the SETMEM function should be used to free memory from QB, if you
need base memory for the volume table. To turn the sound engine off, call
DQBremoveSB; this is anyway automatically called for you by DQBclose. See
also DQBloadSound, DQBplaySound, DQBstopVoice


Example:

See DQBplaySound example


-----------------------------------------------------------------------------
DQBinUse FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBinUse (BYVAL Voice)

Calling:

˛   Voice       Voice number to retrive the status of

Returns:

True if a sound is currently being played on specified voice


Description:

DQBinUse returns true if any sound is currently playing on the specified
voice, otherwise false.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBjoyDetected FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBjoyDetected (BYVAL JoyNum)

Calling:

˛   JoyNum      Joystick number to detect

Returns:

True if specified joystick has been detected, otherwise false


Description:

This function should be called before using the other joystick functions, to
detect if a joystick is available. The parameter JoyNum can be 0 for joystick
1, 1 for joystick 2 or 2 for 4-button joystick. If you can't remember this,
just call this function, as well as the other joystick functions, with the
constants JOY1, JOY2 and GAMEPAD defined into the file DIRECTQB.BI, and
explained into appendix A.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Finds if joystick 1 is available
IF DQBjoyDetected(JOY1) THEN
    PRINT "Joystick 1 detected"
ELSE
    PRINT "Joystick 1 not detected"
END IF

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBjoyFire FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBjoyFire (BYVAL JoyNum, BYVAL Button)

Calling:

˛   JoyNum      Joystick number to retrieve status of
˛   Button      Button number to check

Returns:

True if specified button of specified joystick is pressed, otherwise false


Description:

This function is used to check if a button of a specified joystick is being
pressed. About the parameter JoyNum, please refer to the DQBjoyDetected
function. The other parameter, Button, can be 0 for button A, or 1 for button
B. If you're handling a 4-buttons joystick, you can also use 2 and 3 for
buttons 3 and 4. As for the joystick number, also the buttons have constants
named BUTA, BUTB, BUTC and BUTD declared into the file DIRECTQB.BI, and
explained into appendix A.

Notes:

none


Example:

See DQBjoyMove example


-----------------------------------------------------------------------------
DQBjoyMove FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBjoyMove (BYVAL JoyNum, BYVAL Direction)

Calling:

˛   JoyNum      Joystick number to retrieve status of
˛   Direction   Direction to check, see below

Returns:

True if the joystick is moved into the given direction, otherwise false


Description:

Call this function to know where the joystick has been moved. About the JoyNum
parameter refer to the DQBjoyDetected function. The Direction parameter is an
integer that must be set to: 

-   0     to check if the joystick has been moved up
-   1     to check if the joystick has been moved down
-   2     to check if the joystick has been moved left
-   3     to check if the joystick has been moved right

There are of course four constants for this parameter, named UP, DOWN, LEFT
and RIGHT, declared into the file DIRECTQB.BI, and explained into appendix A.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'
DIM X, Y, Col

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

IF NOT DQBjoyDetected(JOY1) THEN
    PRINT "Joystick 1 not detected, program aborted."
    DQBclose
    END
END IF

DQBinitVGA

X = 150: Y = 90

DO
    ' Polls joystick 1
    DQBpollJoy JOY1
    
    ' Checks movements
    IF DQBjoyMove(JOY1, UP) THEN Y = Y - 1      ' Joystick 1 up

    IF DQBjoyMove(JOY1, DOWN) THEN Y = Y + 1    ' Joystick 1 down

    IF DQBjoyMove(JOY1, LEFT) THEN X = X - 1    ' Joystick 1 left

    IF DQBjoyMove(JOY1, RIGHT) THEN X = X + 1   ' Joystick 1 right

    ' Adjust coordinates
    IF X < 0 THEN X = 0
    IF X > 299 THEN X = 299
    IF Y < 0 THEN Y = 0
    IF Y > 179 THEN Y = 179

    ' Resets box color to white
    Col = 15

    ' If button A is pressed, change color to red
    IF DQBjoyFire(JOY1, BUTA) THEN Col = 40

    ' If button B is pressed, change color to green
    IF DQBjoyFire(JOY1, BUTB) THEN Col = 2

    ' Clears the contents of layer 1
    DQBclearLayer 1

    ' Draws the box
    DQBboxf 1, X, Y, (X + 19), (Y + 19), Col

    ' Waits for vertical retrace 1 time
    DQBwait 1

    ' Copies out layer to the screen
    DQBcopyLayer 1, VIDEO

    ' Prints a message
    LOCATE 1
    PRINT "  Joystick demo - press a key to exit!"

LOOP WHILE INKEY$ = ""

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBjoyX FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBjoyX (BYVAL JoyNum)

Calling:

˛   JoyNum      Joystick number to x axis position of

Returns:

An INTEGER value holding the current joystick x axis position


Description:

This function can be used to retrieve the exact x axis position of specified
joystick, relatively to the center position, that is automatically detected
at startup, or by calling DQBresetJoy.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBjoyY FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBjoyY (BYVAL JoyNum)

Calling:

˛   JoyNum      Joystick number to y axis position of

Returns:

An INTEGER value holding the current joystick y axis position


Description:

This function can be used to retrieve the exact y axis position of specified
joystick, relatively to the center position, that is automatically detected
at startup, or by calling DQBresetJoy.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBkey FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBkey (BYVAL ScanCode)

Calling:

˛   ScanCode    Scancode of the key to retrieve status of

Returns:

True if the key is pressed, otherwise false


Description:

This function returns useful information only when the custom keyboard
interrupt handler has been installed by calling DQBinstallKeyboard. For a
complete list of keyboard scancodes, refer to appendix B. There're also a few
constants declared into the file DIRECTQB.BI, such as KEYESC, KEYENTER, KEYUP,
KEYDOWN, KEYLEFT, KEYRIGHT and others, explained into appendix A.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Let's install the custom keyboard handler
DQBinstallKeyboard

CLS
PRINT "Keyboard demo - press any key to see its scancode. Multiple
keypresses are allowed; press ESC to exit."

DO
    LOCATE 3, 1

    ' Scans every possible key
    FOR i = 0 TO 127
        ' If the key is pressed, prints its scancode
        IF DQBkey(i) THEN PRINT "[" + LTRIM$(STR$(i)) + "] ";
    NEXT i

    ' Clears a portion of the screen
    PRINT SPACE$(40)

' Loops while the ESC key is not pressed
LOOP UNTIL DQBkey(KEYESC)

' Uninstalls the keyboard handler (this is not really needed when we're
' going to end the program by calling DQBclose)
DQBremoveKeyboard

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBlen FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBlen (Text AS STRING)

Calling:

˛   Text        Text string to retrieve the length of

Returns:

An INTEGER holding the length in pixels of the given string, assuming the
current font characters length


Description:

Like LEN, DQBlen returns the length of a specified string, but in pixel units.
As DirectQB supports non-fixed sized fonts, this function is useful to
retrieve the length of a string in pixels, calculated using the length of
the characters of the current font.

Notes:

none


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

Length = DQBlen("The length of this string is:")
DQBprint VIDEO, "The length of this string is:" + STR$(Length) + " pixels", 0, 0, 31

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBline SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBline (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                     BYVAL Col)

Calling:

˛   Layer       Layer where to draw the line onto
˛   x1          First point x coordinate
˛   y2          First point y coordinate
˛   x2          Second point x coordinate
˛   y2          Second point y coordinate
˛   Col         Drawing color

Returns:

none


Description:

This procedure draws a line from point at (x1,y1) to point at (x2,y2), on the
given layer and with specified color. The Bresenham's line algorithm is used.

Notes:

DQBline is affected by the clipping box; see also DQBgline


Example:

none


-----------------------------------------------------------------------------
DQBloadBMap FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBloadBMap (BMap AS INTEGER, FileName AS STRING)

Calling:

˛   BMap        Number of the blender map to load data into
˛   FileName    Blender map file name with full extension

Returns:

An INTEGER value holding the loading results:

>   0     Loading successful
>   1     Blender map not yet created
>   2     Cannot open file, or file does not exist
>   3     Bad or unknown file format
>   4     Incompatible blender map
>   5     General reading error


Description:

Loads data from a specified binary file into the blender map; the blender map
must have been previously created by calling DQBcreateBMap.

Notes:

The bmap number where to load data onto must be compatible with the bmap
saved on the file: this means that the number of mapped foreground colors
must be the same for both the bmap stored on the file and the bmap structure
where you are about to load it into. See also DQBcreateBMap and DQBsaveBMap


Example:

none


-----------------------------------------------------------------------------
DQBloadFont FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBloadFont (FileName AS STRING)

Calling:

˛   FileName    Font file with full extension

Returns:

An INTEGER value holding the loading results:

>   0     Loading successful
>   1     Cannot open file, or file does not exist
>   2     General reading error


Description:

Loads and sets a font from a specified file. The font file must contain the
data in the first 2305 bytes, in the format explained into appendix C.

Notes:

This function is useful as it doesn't require a QB buffer to hold the data;
the disadvantage of using it, is that every time you change the font, the disk
is accessed. By using DQBsetFont instead, you can keep your fonts in QB memory
and set them as needed.


Example:

none


-----------------------------------------------------------------------------
DQBloadImage FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBloadImage (Layer AS INTEGER, x AS INTEGER, y AS INTEGER,
                               FileName AS STRING, Pal AS STRING, ImgWidth AS
                               INTEGER, ImgHeight AS INTEGER)

Calling:

˛   Layer       Layer where to load the image onto
˛   x           x position where to begin drawing
˛   y           y position where to begin drawing
˛   FileName    Image file name with full extension
˛   Pal         String where the image palette is loaded into
˛   ImgWidth    Integer variable to store the image width
˛   ImgHeight   Integer variable to store the image height

Returns:

An INTEGER value holding the loading results:

>   0     Loading successful
>   1     Cannot open file, or file does not exist
>   2     General reading error
>   3     Bad or unknown file format


Description:

Loads an image into specified layer, at specified coordinates. Images can be
of any size, up to 320x200 pixels, but it must have been saved with 256 colors.
You can load BMP, PCX or BSAVEd files; the format is automatically detected
and it's independent from the file extension. The function returns 0 if the
operation is successful, otherwise an error code (see above). When loading a
BMP or a PCX image, the palette is stored into the Pal string; current palette
is not changed, allowing you to change it only when you want, by calling
DQBsetPal or DQBfadeIn, or any way you like. In the case you're loading a BSV
image, the function searches for the palette appended at the end of the file;
if it finds it, you'll get it stored into the Pal string as well. In all cases,
the image width and height will be stored into the ImgWidth and ImgHeight
variables.

Notes:

See appendix C to know the palette string format


Example:

none


-----------------------------------------------------------------------------
DQBloadRawSound FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBloadRawSound (Slot AS INTEGER, FileName AS STRING,
                                  Offset AS LONG, Length AS INTEGER)

Calling:

˛   Slot        Sound slot to load the sound into
˛   FileName    Sound file name with full extension
˛   Offset      File position where to begin to load in bytes
˛   Length      Sound data length in bytes

Returns:

An INTEGER value holding the loading results:

>   0     Loading successful
>   1     Cannot open file, or file does not exist
>   2     General reading error
>   3     Cannot read past the end of file
>   4     Specified sound slot does not exist


Description:

Loads sound data from a specified position on a given file. This function
does not check for the data format, and directly stores the sound into the
specified slot. DQBloadRawSound can be useful to handle sound data files
holding multiple sounds data, as well as when DQBloadSound fails the sound
data format check.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBloadSound FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBloadSound (Slot AS INTEGER, FileName AS STRING)

Calling:

˛   Slot        Sound slot to load sound into
˛   FileName    Sample file name with full extension

Returns:

An INTEGER value holding the loading results:

>   0     Loading successful
>   1     Cannot open file, or file does not exist
>   2     General reading error
>   3     Bad or unknown file format
>   4     Sound format not yet supported
>   5     Sound file exceeds the 64K length limit
>   6     Specified sound slot does not exist


Description:

Loads a sound sample from file and stores it into EMS. The "Slot" parameter
identifies the sound effect and is used by the DQBplaySound function.

Notes:

Only 8-bit mono WAV files are supported for now, so be warned.


Example:

See DQBplaySound example


-----------------------------------------------------------------------------
DQBmapLayer FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmapLayer (BYVAL Layer)

Calling:

˛   Layer       Number of the layer to map

Returns:

An INTEGER value holding the segment where you can access the layer data


Description:

This function is useful when you want to have complete control over a
specified layer: infact DQBmapLayer returns the segment of the 64K memory
window where the layer data is held. If the layer is on EMS, the function
returns the EMS pageframe, and it also map it to the specified layer data.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBmouseDetected FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmouseDetected ()

Calling:

none

Returns:

An INTEGER value holding the mouse initialization result:

>   0     Mouse not detected
>   -1    Mouse detected and successfully initialized


Description:

Returns true if a mouse has been detected on your system; you should call this
before calling any other mouse routine.

Notes:

It is recommended that you also call DQBresetMouse just after setting mode
13h by calling SCREEN 13, before using any other mouse routine.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Checks if a mouse has been detected
IF NOT DQBmouseDetected THEN
    ' Mouse has not been detected
    PRINT "This demo requires a mouse to run!"
    DQBclose
    END
END IF

DQBinitVGA

' Resets the mouse cursor and range
DQBresetMouse

' Sets a new mouse range
DQBsetMouseRange 6, 6, 314, 148

DO
    ' Let's clear layer 1
    DQBclearLayer 1

    DQBbox 1, 5, 5, 315, 149, 32

    ' Prints some stats
    DQBprint 1, "PRESS ANY KEY TO EXIT DEMO", 0, 170, 40

    ' Prepares our info string
    Info$ = "Mouse is at" + str$(DQBmouseX) + "," + str$(DQBmouseY)
    Info$ = Info$ + " - Buttons: " + str$(DQBmouseLB) + " " + str$(DQBmouseRB)

    DQBprint 1, Info$, 0, 180, 40

    ' Hides the mouse cursor before drawing to the screen
    DQBmouseHide

    ' Copies layer 1 onto the screen
    DQBcopyLayer 1, VIDEO

    ' Shows the cursor again
    DQBmouseShow

' Loops while no keys are pressed
LOOP WHILE INKEY$ = ""

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBmouseHide SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBmouseHide ()

Calling:

none

Returns:

none


Description:

Hides the mouse cursor if it was visible. Though the mouse is not visible, it
remains active.

Notes:

See DQBmouseShow


Example:

See DQBmouseDetected example


-----------------------------------------------------------------------------
DQBmouseLB FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmouseLB ()

Calling:

none

Returns:

-1 if the left mouse button is currently pressed, otherwise 0


Description:

Call this function to know if the left mouse button is pressed or released.
It can be called at any time, as the mouse status is automatically checked.

Notes:

none


Example:

See DQBmouseInit example


-----------------------------------------------------------------------------
DQBmouseRB FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmouseRB ()

Calling:

none

Returns:

-1 if the right mouse button is currently pressed, otherwise 0


Description:

Call this function to know if the right mouse button is pressed or released.
It can be called at any time, as the mouse status is automatically checked.

Notes:

none


Example:

See DQBmouseInit example


-----------------------------------------------------------------------------
DQBmouseShow SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBmouseShow ()

Calling:

none

Returns:

none


Description:

Shows the mouse cursor if it was not visible.

Notes:

none


Example:

See DQBmouseInit example


-----------------------------------------------------------------------------
DQBmouseX FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmouseX ()

Calling:

none

Returns:

An INTEGER value holding the current mouse x coordinate


Description:

Call this function at any time to know the current mouse x position.

Notes:

The position is given in pixel units, and ranges depending on the actual
mouse range box. This can be changed by calling DQBsetMouseRange.


Example:

See DQBmouseInit example


-----------------------------------------------------------------------------
DQBmouseY FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBmouseY ()

Calling:

none

Returns:

An INTEGER value holding the current mouse y coordinate


Description:

Call this function at any time to know the current mouse y position.

Notes:

The position is given in pixel units, and ranges depending on the actual
mouse range box. This can be changed by calling DQBsetMouseRange.


Example:

See DQBmouseInit example


-----------------------------------------------------------------------------
DQBmPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBmPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL Flip)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   Flip        Flip flag

Returns:

none


Description:

This function works almost like DQBput, but it allows the user to draw sprites
horizontally or vertically (or both them) flipped. The flip parameter tells
DQBmPut how to flip the sprite: 0 means the sprite will be drawn as is, 1 that
it'll look like as it was horizontally mirrored and 2 vertically mirrored.
A value of 3 (1+2) means that both effects will be applied to the sprite. You
can use the constants defined in DIRECTQB.BI to simplify your calls; see
appendix A for details.


Notes:

DQBmPut supports transparency and clipping; see also DQBput.


Example:

none


-----------------------------------------------------------------------------
DQBnumDrives FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBnumDrives

Calling:

none

Returns:

An INTEGER value holding the number of drives


Description:

This function returns the number of available logical drives. A value of 3
for example means you have A: B: and C:, and so on.

Notes:

See also DQBdir$, DQBpath$, DQBdrive$, DQBsetDrive


Example:

See DQBdir$ example


-----------------------------------------------------------------------------
DQBopenDataFile FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBopenDataFile (FileName AS STRING, Password AS STRING)

Calling:

˛   FileName    Datafile to open
˛   Password    Password for data decoding

Returns:

>   0     Operation successful
>   1     Cannot open file or file does not exist
>   2     General file reading error
>   3     Bad datafile format
>   4     Can't open two datafiles at once


Description:

Opens a datafile and sets decoding password. The datafile must have been
created by the DQB DataFile Encoder program, or any other program able to
generate DQB compatible datafiles. Password can be any string up to 8 chars.

Notes:

As password, you can also pass a null string, meaning the datafile is not
password-protected. You cannot open two datafiles at once: if you need to
access the data that's stored onto another file, you must first close the
current opened one with the DQBcloseDataFile function. See also DQBunpackImage,
DQBunpackSprite, DQBunpackSound, DQBunpackPal, DQBunpackBMap, DQBunpackFont,
DQBunpackCursor, DQBunpackUser, and appendix C for the datafile file format


Example:

*****************************************************************************

' This example assumes there's a datafile named TEST.BIN, containing an image
' whose ID is SAMPLE (stored into TEST.BI).

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Here we include the BI file generated by DQBENC for our datafile
'$INCLUDE:'TEST.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Opens datafile TEST.BIN, using password PASS
IF DQBopenDataFile("TEST.BIN","PASS") THEN DQBclose: PRINT DQBerror$: END

' Setups VGA
DQBinitVGA

' Unpacks on the screen from TEST.BIN the image whose ID is SAMPLE, placing
' it at coordinates (0,0)
IF DQBunpackImage(SAMPLE, VIDEO, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Closes datafile (not really needed here, as DQBclose does it automatically)
DQBcloseDataFile

' Ends program
DQBclose
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBopenFLI FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBopenFLI (FileName AS STRING, Frames AS INTEGER, Speed AS
                        INTEGER)

Calling:

˛   FileName    FLI animation file name
˛   Frames      Integer variable that will hold the total frames number
˛   Speed       Integer variable that will hold the animation speed factor

Returns:

>   0     Operation successful
>   1     Not enough free base memory
>   2     Cannot open file or file does not exist
>   3     General file reading error
>   4     Bad or unknown file format
>   5     A FLI file has already been opened


Description:

Opens a FLI file and initializes the animation. The DQB internal FLI routines
cannot handle more than one file opened at the same time, so if you call this
function and then you try to call it again, or to call DQBplayFLI, you'll get
error 5; an animation file can be closed by using the DQBclose function.
DQBopenFLI also allows you to know the number of frames and the speed of the
specified FLI file, by passing QB variables to the function.

Notes:

As for normal DQBplayFLI, also this function requires 64K of additional
conventional memory as decoding buffer. See also DQBcloseFLI, DQBplayFLIstep,
DQBplayFLI


Example:

See DQBplayFLIstep example


-----------------------------------------------------------------------------
DQBpaint SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpaint (BYVAL Layer, BYVAL x, BYVAL y, BYVAL Col)

Calling:

˛   Layer       Layer where to act
˛   x           X coordinate where to start filling
˛   y           Y coordinate where to start filling
˛   Col         Filling color

Returns:

none


Description:

As normal PAINT statement, this function fills any closed area, by starting
to fill at specified coordinates; the area is filled until a border with a
color different from specified one is encountered.

Notes:

Actually this function is slower than normal PAINT, but unlike it, DQBpaint
has the advantage that it fills only until a border with any different color
is hit.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Draws a closed figure on the screen
DQBellipse VIDEO, 160, 100, 100, 60, 40
DQBbox VIDEO, 100, 30, 150, 110, 11

' Paints it!
DQBpaint VIDEO, 160, 100, 4

' Let's wait for the user to press a key...
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBpalOff SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpalOff ()

Calling:

none

Returns:

none


Description:

By calling this function, the current palette is all set to black. This can
be used to turn off the screen when preparing it.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBpalRotate SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpalRotate (BYVAL FirstCol, BYVAL LastCol, BYVAL RotDir)

Calling:

˛   FirstCol    First color index of palette interval to rotate
˛   LastCol     Last color index of palette interval to rotate
˛   RotDir      Rotating direction flag

Returns:

none


Description:

Rotates forward or backward the interval of the current palette specified by
the FirstCol and LastCol parameters. If RotDir is 0, the palette is rotated
forward, otherwise backward; you can use the FORWARD or BACKWARD constants
defined into DIRECTQB.BI, as explained into appendix A

Notes:

LastCol must be greater or equal than FirstCol. See also DQBsetCol, DQBgetCol,
DQBsetPal and DQBgetPal


Example:

none


-----------------------------------------------------------------------------
DQBpath$ FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBpath$ ()

Calling:

none

Returns:

A string holding the current drive path


Description:

DQBpath$ returns the actual full path of the current drive; Windows long
directory names are supported.

Notes:

See also DQBdir$, DQBdrive$, DQBnumDrives, DQBsetDrive


Example:

See DQBdir$ example


-----------------------------------------------------------------------------
DQBpauseSound SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpauseSound ()

Calling:

none

Returns:

none


Description:

Pauses voices sound output.

Notes:

See also DQBresumeSound


Example:

none


-----------------------------------------------------------------------------
DQBpeek SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpeek (BYVAL DataSeg, BYVAL DataOff, BYVAL Offset AS LONG,
                     BYVAL Length)

Calling:

˛   DataSeg     Segment of QB array or variable where data is copied from EMS
˛   DataOff     Offset of QB array or variable where data is copied from EMS
˛   Offset      Absolute offset into allocated EMS memory where to take data
˛   Length      Length in bytes to copy

Returns:

none


Description:

DQBpeek allows to copy data from the user EMS memory area (whose dimension was
set by the third parameter of the DQBinit function) into a QB array or
variable. The Offset parameter specifies in byte units where to begin copying
data; this offset is absolute, and this means you refer to your user EMS
memory poll as a flat table. Length bytes are copied from EMS.

Notes:

This function works best with big amount of data; see also DQBpoke


Example:

See DQBpoke example


-----------------------------------------------------------------------------
DQBplayFLI FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBplayFLI (FileName AS STRING, BufLayer AS INTEGER, KeyStop
                             AS INTEGER, LoopFlag AS INTEGER)

Calling:

˛   FileName    FLI file name
˛   BufLayer    Layer to be used for double buffering
˛   KeyStop     Scancode of the stop key
˛   LoopFlag    Flag for animation looping

Returns:

>   0     Operation successful
>   1     Not enough free base memory
>   2     Cannot open file or file does not exist
>   3     General file reading error
>   4     Bad or unknown file format


Description:

Plays a whole animation from a specified FLI file; actually, FLC files are not
supported. The file can be played using a double buffer, to achieve
flickerless animations: using this feature requires an additional existing
layer number to be specified into the "BufLayer" parameter; this layer can be
in EMS as well as in conventional memory. If you tell the function to use the
VIDEO as the needed layer, the animation will be decoded directly onto the
screen, avoiding the double buffering. On fast computers this will look almost
the same as if the buffer is used, but on older machines it is recommended
that you always use buffered decoding. The animation can be looped, and you
can also specify a key to stop it at any time and return the execution to your
program. By specifying KEYANY as "KeyStop" parameter, the player will stop
once any key is pressed; if you don't want to allow the user to stop an
animation, pass NONE as this parameter. The use of the stop key feature
requires that the DirectQB keyboard handler has been previously installed,
otherwise the function will ignore any keyboard strokes. The last parameter
tells DQBplayFLI whenever to loop the animation once the last frame is
reached; you can use the ONCE and LOOPED constants here. To avoid infinite
loops, if you want to play a looped animation you must also specify a stop
key, and therefore you must first install the keyboard handler. If no stop
key is defined, and you try to play an animation with looping, it'll be
played as if the ONCE mode was selected.

Notes:

Other than the layer used for double buffering, this function also requires
64K of free conventional memory for fast decoding purposes. As always, you
should call SETMEM to free some memory from the QB far heap, so that DQB
functions can use it. If you're also using a blender map, and you don't have
so much free base mem, you may want to call DQBremoveBmap before calling
DQBplayFLI, and then reallocate it after the animation ends; this way only
64K of memory are required. If you want to have more control over the
animation (like adding text over each frame before showing it, or changing
the playback speed), you can use the DQBopenFLI, DQBplayFLIstep and
DQBcloseFLI functions; check them out!


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Prompts the user for the FLI file name
INPUT "Enter full FLI file name (hit enter to quit): ", FileName$

' Switches to VGA mode
DQBinitVGA

' Installs the keyboard handler
DQBinstallKeyboard

' Frees 64K of memory for animation decoding
dummy& = SETMEM(-66000)

IF FileName$ <> "" THEN

  ' Plays looped animation, using layer 1 for double buffering
  IF DQBplayFLI(FileName$, 1, KEYANY, LOOPED) THEN
    ' An error has occured
    DQBclose
    PRINT DQBerror$
    dummy& = SETMEM(66000)
    END

  END IF

END IF

' The animation stops whenever the user press any key
DQBclose
dummy& = SETMEM(66000)
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBplayFLIstep SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBplayFLIstep (BYVAL Layer)

Calling:

˛   Layer       Layer where the frame has to be drawn onto

Returns:

none


Description:

Decodes the next frame of a FLI file onto a specified layer. The animation
must have been opened with DQBopenFLI before calling this function; on errors
DQBplayFLIstep will do nothing. When the last frame is reached, this sub will
automatically restart from the first one, so it's up to the user to stop the
animation at the right time. It's also up to the user to add a proper delay
before copying the frame onto the screen: by the way, DQBopenFLI returns both
the total number of frames and the speed factor of the FLI file to be opened.
The speed factor can be used as a parameter to the DQBwait function, to
achieve the default animation speed.

Notes:

Of course you can decode each frame directly onto the screen, but as explained
into the description of the DQBplayFLI routine, this could not look so good
on older computers... Also, keep in mind that by calling this function, the
palette may change at any time as the FLI animation is playing. In addition,
you should know that when a new frame is decoded onto a layer, only the parts
of it that are changed from the last frame are drawn (that's the FLI standard)
so if you plan to draw some moving stuff over the animation, you should
always decode each frame onto the same layer, copy this layer onto a new one,
and then draw your own stuff on this last one before copying it on the screen.


Example:

*****************************************************************************

' This program does the exact thing as the example of DQBplayFLI, but this
' one uses the three functions DQBopenFLI, DQBplayFLIstep and DQBclose to
' achieve the result.

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's declare two variables to hold the number of frames and speed factor
DIM FramesNumber AS INTEGER, SpeedFactor AS INTEGER

' Initializes the library with one extra layer and no sounds nor EMS
IF DQBinit(2, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Prompts the user for the FLI file name
INPUT "Enter full FLI file name (hit enter to quit): ", FileName$

IF FileName$ = "" THEN DQBclose: END

' Frees 64K of memory for animation decoding
dummy& = SETMEM(-66000)

' Opens the animation file and gets infos on it
IF DQBopenFLI(FileName$, FramesNumber, SpeedFactor) THEN
  ' An error has occured
  DQBclose
  dummy& = SETMEM(66000)
  PRINT DQBerror$: END
END IF

' Shows some stats to the user
PRINT FileName$ + " contains" + STR$(FramesNumber) + " frames and has a ";
PRINT "speed factor of" + STR$(SpeedFactor)
PRINT "Press a key to continue..."
WHILE INKEY$ = "": WEND

' Switches to VGA mode
DQBinitVGA

' Plays the animation and automatically loops it
DO
  ' Decodes next frame on layer 2
  DQBplayFLIstep 2

  ' Copies new frame into layer 1, so we can draw on it without problems
  DQBcopyLayer 2, 1

  ' Now the frame has been drawn onto layer 1; you can do your stuff here
  ' ...

  ' Adds delay and copies the frame onto the screen
  DQBwait SpeedFactor
  DQBcopyLayer 1, VIDEO
LOOP WHILE INKEY$ = ""

' The animation stops whenever the user press any key
' Closes the FLI file
DQBcloseFLI

' Ends program
DQBclose
dummy& = SETMEM(66000)
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBplaySound SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBplaySound (BYVAL Slot, BYVAL Voice, BYVAL Freq, BYVAL LoopFlag)

Calling:

˛   Slot        Slot holding the sound data
˛   Voice       Sound channel to use
˛   Freq        Playing frequency
˛   LoopFlag    Specifies to play the sound once or repeatedly

Returns:

none


Description:

Plays a sound effect previously stored into EMS by the DQBloadSound function
into a specified slot. The voice parameter can range from 1 to the maximum
number of voices specified when calling DQBinstallSB, and tells which sound
channel to use. If LoopFlag is 0, the sound is played once, while if the
LoopFlag is 1 the sound is looped. There are two constants defined into
DIRECTQB.BI that helps you using the LoopFlag parameter: they are the ONCE
and the LOOPED constants. The DQB sound engine supports sound resampling:
you specify the output frequency for each sound you play, and the sound will
be resampled and played in realtime.

Notes:

If you play a sound while another one is still playing on the same voice,
the old one is stopped and the new starts. To stop any sound playing on a
voice, call DQBstopVoice.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layer nor EMS, and one sound
IF DQBinit(0, 1, 0) THEN DQBclose: PRINT DQBerror$: END

' Frees 16K of base memory for the sound engine volume table
dummy& = SETMEM(-17000)

' Initializes the sound engine, by passing 220h as the base address and by
' autodetecting the IRQ and DMA settings. 2 voices are initialized, sampling
' rate is set to 22 KHz, and the volume table is built.
IF DQBinstallSB(TRUE, 2, 22050, &H220, AUTO, AUTO) THEN
    ' Bad initialization
    DQBclose
    PRINT DQBerror$
    END
END IF

' Asks the user for the location of a WAV file to load
INPUT "Insert the WAV file name to load:", File$

' Loads the sound in memory
IF DQBloadSound(1, File$) THEN DQBclose: PRINT DQBerror$: END

PRINT "Press a key to exit..."

' Plays sound 1 at 22 Khz on voice 2 once
DQBplaySound 1, 2, 22050, ONCE

' Waits a key
WHILE INKEY$ = "": WEND

' Turns off the sound engine (that's not really needed, as it's automatically
' done for you by the DQBclose function)
DQBremoveSB

' Ends program
DQBclose
dummy& = SETMEM(17000)

*****************************************************************************


-----------------------------------------------------------------------------
DQBpoint FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBpoint (BYVAL Layer, BYVAL x, BYVAL y)

Calling:

˛   Layer       Layer where to get the pixel from
˛   x           Pixel x coordinate
˛   y           Pixel y coordinate

Returns:

An INTEGER value holding the color number of specified pixel


Description:

Call this function to retrieve the color number of a specified pixel.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBpoke SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpoke (BYVAL DataSeg, BYVAL DataOff, BYVAL Offset AS LONG,
                     BYVAL Length)

Calling:

˛   DataSeg     Segment of QB array or variable where is data to copy to EMS
˛   DataOff     Offset of QB array or variable where is data to copy to EMS
˛   Offset      Absolute offset into allocated EMS memory where to copy data
˛   Length      Length in bytes to copy

Returns:

none


Description:

DQBpoke is used to write data from a QB array or variable, into the user EMS
memory poll; you must specify the address and the length in bytes of the
source data, plus an offset into EMS where to copy it. As for DQBpeek, this
address is absolute, so you refer to your user EMS area as a flat memory area.

Notes:

Never try to copy data when it (or a part of it) will lie outside the user
EMS memory area set by the DQBinit function; you may end with a machine crash.
See also DQBpeek


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'directqb.bi'

' Let's initialize the library with no layers nor sounds, but 100KB of EMS
IF DQBinit(0, 0, 100) THEN DQBclose: PRINT DQBerror$: END

' Here we declare a string we'll copy to EMS
DIM Text AS STRING * 30
Text = "This is a test!!"

' Let's display our string
PRINT "Now the string is: " + Text

' Copies the string to EMS, at address 0 of our user memory area
DQBpoke VARSEG(Text), VARPTR(Text), 0, 30

' Clears our string and display it
Text = ""
PRINT "Now the string is: " + Text

' Gets back the string from the EMS user memory area
DQBpeek VARSEG(Text), VARPTR(Text), 0, 30

' Displays it again
PRINT "Now the string is: " + Text

' Ends program
DQBclose
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBpollJoy SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpollJoy (BYVAL JoyNum)

Calling:

˛   JoyNum      Joystick number to retrieve information of

Returns:

none


Description:

This function must be always called before calling DQBjoyMove or DQBjoyFire,
as it updates the internal joystick variables. The JoyNum parameter must be
0 or 1 for joystick 1 and 2; there're two contants for this purpose, as
explained into appendix A.

Notes:

This is a relatively slow operation; in addition, if specified joystick is
not connected, this will be even slower, so it is recommended that you check
if the joystick is available before calling DQBpollJoy.


Example:

See DQBjoyMove example


-----------------------------------------------------------------------------
DQBpPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL Pattern)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   Pattern     Bit pattern (see below)

Returns:

none


Description:

Draw a sprite as DQBput, but uses a specified 8-bit pattern to determine which
pixel is to be drawn or not. So if the pattern looks like 01010101 (number 85
in decimal format), one pixel will be drawn, and the next one will be skipped,
then the process begins again. The pattern wraps until the end of each sprite
line, and on every new line it's xored by 255: this means that the same
example pattern will look like 10101010 on the second sprite line, and again
as 01010101 on the third, etc...

Notes:

By alternating the bit-pattern and drawing sprites quickly using this function,
you can achieve translucency-like effects, but without the need of a blender
map. Use it wisely!


Example:

none


-----------------------------------------------------------------------------
DQBprint SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBprint (Layer AS INTEGER, Text AS STRING, x AS INTEGER,
                      y AS INTEGER, Col AS INTEGER)

Calling:

˛   Layer       Layer where to draw the text
˛   Text        String to print
˛   x           X position of upper left corner of the first character
˛   y           Y position of upper left corner of the first character
˛   Col         Text color

Returns:

none


Description:

This function will print the specified string onto the given layer. By
default, the VGA BIOS font is used, but any font can be used by first calling
DQBsetFont. Also, the last style selected by DQBsetTextStyle is used. The x
and y parameters are in pixel units, so you can print the text anywhere on
specified layer. If you specify a x value of &H8000 (or you type in the
constant CENTERED - see appendix A) the text is automatically centered on
the current viewport set by the last call to DQBsetClipBox (that's by default
the entire screen)

Notes:

DQBprint supports clipping, so pixels outside the clipping box will not be
drawn. See also DQBprints, DQBsetTextStyle, DQBsetFont and DQBsetBIOSfont.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Prints text on the center of the screen in bright red
DQBprint VIDEO, "This is a DQBprint test!", CENTERED, 96, 40

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBprints SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBprints (Layer AS INTEGER, Text AS STRING, x AS INTEGER,
                       y AS INTEGER, Col AS INTEGER, Style AS INTEGER)

Calling:

˛   Layer       Layer where to draw the text
˛   Text        String to print
˛   x           X position of upper left corner of the first character
˛   y           Y position of upper left corner of the first character
˛   Col         Text color
˛   Style       Custom text style

Returns:

none


Description:

DQBprints works exactly like DQBprint, but it requires an additional parameter
that allows to specify the style of the output text. Specified style is
applied only to one call of this function; once the text has been drawn, the
original text style is restored. For the styles, see appendix A for a list of
constants, and take a look at the DQBsetTextStyle function.

Notes:

DQBprints supports clipping, so pixels outside the clipping box will not be
drawn. See also DQBprint, DQBsetTextStyle, DQBsetFont and DQBsetBIOSfont.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Uses normal font with DQBprint
DQBprint VIDEO, "This is a normal text", 0, 0, 31

' Uses normal font with the bold style
DQBprints VIDEO, "I'm big and fat, I'm bold style!", 0, 10, 31, BOLD
' Uses italic style on the same font
DQBprints VIDEO, "Italic style is very nice", 0, 20, 31, ITALIC
' Uses underlined style again on the same font
DQBprints VIDEO, "Pay attention to underlined text", 0, 30, 31, UNDERLINED
' Uses a combination of styles on the same font
DQBprints VIDEO, "Bold and italic together!", 0, 40, 31, BOLD + ITALIC

' Back to normal text
DQBprint VIDEO, "That's all folks!", 0, 50, 31

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBpset SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBpset (BYVAL Layer, BYVAL x, BYVAL y, BYVAL Col)

Calling:

˛   Layer       Layer where to draw the pixel
˛   x           Pixel x coordinate
˛   y           Pixel y coordinate
˛   Col         Pixel color

Returns:

none


Description:

Sets a pixel onto specified layer, at given coordinates and with Col color.

Notes:

This function is affected by the clipping box set by DQBsetClipBox.


Example:

none


-----------------------------------------------------------------------------
DQBput SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBput (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                    BYVAL SpriteOff)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR

Returns:

none


Description:

Draws the sprite contained into the given array on specified layer, at the
given coordinates. DQBput can operate both in transparent and solid mode:
when the first mode is set, pixels with color 0 of the sprite are skipped,
allowing a transparent put, when the second mode is set, all the pixels are
copied to the layer, destroying the background. By default the put mode is
set to transparent, but it can be changed at any time by simply calling
DQBsetTransPut and DQBsetSolidPut.

Notes:

DQBput is affected by the clipping box, so pixels outside this box will not
be drawn. The sprite data format is compatible with normal GET and PUT, so
you can get you sprite data by calling either GET or DQBget. See also DQBfPut,
DQBsPut, DQBrPut and DQBbPut.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' We're going to use 15 sprite 16x16 pixels each; let's call DQBsize to
' know the dimension of our sprite array (we'll store all the sprites into
' the same array) in bytes
Size = DQBsize(0, 0, 15, 15)
' Our array is made of INTEGERs, so we divide Size by 2
DIM Sprite((Size \ 2) * 15)

' Let's prepare our sprites
FOR i = 0 TO 14

  ' Let's clear layer 1
  DQBclearLayer 1

  ' Draws a frame of our sprite
  DQBbox 1, 0, 0, 15, 15, 4
  DQBline 1, (15-i), 15, i, 0, 40
  DQBline 1, 15, i, 0, (15 - i), 40

  ' Saves the frame into our array
  DQBget 1, 0, 0, 15, 15, VARSEG(Sprite(0)), VARPTR(Sprite(0)) + (Size * i)

NEXT i

DQBinitVGA

FOR i = -16 TO 320

  ' Empties layer 1
  DQBclearLayer 1

  ' Finds what frame to draw
  Frame = ((i + 16) \ 2) MOD 15

  ' Draws our frame into layer 1
  DQBput 1, i, 92, VARSEG(Sprite(0)), (VARPTR(Sprite(0)) + (Size * Frame))

  ' Waits for vertical retrace 1 time
  DQBwait 1

  ' Copies layer 1 onto the screen
  DQBcopyLayer 1, VIDEO

NEXT i

' Ends program
DQBclose

*****************************************************************************

-----------------------------------------------------------------------------
DQBputOver SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBputOver (BYVAL BackSeg, BYVAL BackOff, BYVAL x, BYVAL y,
                        BYVAL SpriteSeg, BYVAL SpriteOff)

Calling:

˛   BackSeg     Segment of the array holding the 1st sprite data; use VARSEG
˛   BackOff     Offset of the array holding the 1st sprite data; use VARPTR
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the 2nd sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the 2nd sprite data; use VARPTR

Returns:

none


Description:

This function allows to draw a sprite over another one. The 1st sprite acts
as the background, and the second one is drawn over it; DQBputOver supports
transparency and the 2nd sprite is automatically clipped to the first one.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBreadBit FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBreadBit (BYVAL Value, BYVAL Bit)

Calling:

˛   Value       INTEGER value to read bit status from
˛   Bit         Bit number, ranging 0-15, to retrieve status of

Returns:

True if specified bit is set, otherwise false


Description:

This function returns true if a specified bit of a specified integer value
is set. It can be useful to store boolean variables into an unique INTEGER
one, as QB does not support booleans. An integer can contain up to 16 boolean
variables!

Notes:

See DQBsetBit, DQBresetBit and DQBtoggleBit


Example:

none


-----------------------------------------------------------------------------
DQBreadKey FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBreadKey ()

Calling:

none

Returns:

An INTEGER value holding the scancode number of the key that has been pressed


Description:

DQBreadKey wait for the user to press a key, and then returns its scancode.
This function works only if the keyboard interrupt handler has been installed
by calling DQBinstallKeyBoard.

Notes:

See DQBinstallKeyboard, DQBkey, DQBwaitKey


Example:

none


-----------------------------------------------------------------------------
DQBremoveBMap SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBremoveBMap (BYVAL BMap)

Calling:

˛   BMap        Blender map number to deallocate  

Returns:

none


Description:

Deallocates memory used by specified blender map and turns it off.

Notes:

This function is automatically called by DQBclose for every active bmap. See
also DQBcreateBMap


Example:

none


-----------------------------------------------------------------------------
DQBremoveKeyboard SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBremoveKeyboard ()

Calling:

none

Returns:

none


Description:

Turns off the custom keyboard interrupt handler if it was on, giving the
keyboard control back to the old BIOS routines. This function is automatically
called by DQBclose.

Notes:

See also DQBinstallKeyboard


Example:

See DQBkey example


-----------------------------------------------------------------------------
DQBremoveSB SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBremoveSB ()

Calling:

none

Returns:

none


Description:

Stops all the sounds playing and turns off the sound engine. This function is
automatically called for you by DQBclose, so there's no particular need to
call it.

Notes:

See also DQBinstallSB


Example:

none


-----------------------------------------------------------------------------
DQBresetBit FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBresetBit (BYVAL Value, BYVAL Bit)

Calling:

˛   Value       INTEGER variable to reset bit of
˛   Bit         Bit number to reset, ranging 0-15

Returns:

An INTEGER value representing the old variable value with specified bit reset


Description:

Call this function to zero a bit of a specified variable. This can be useful
to handle boolean variables.

Notes:

See DQBsetBit, DQBreadBit and DQBtoggleBit


Example:

none


-----------------------------------------------------------------------------
DQBresetJoy SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBresetJoy ()

Calling:

none

Returns:

none


Description:

Resets the joysticks by recalibrating them (where they are available).

Notes:

none


Example:

none



-----------------------------------------------------------------------------
DQBresetMouse SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBresetMouse ()

Calling:

none

Returns:

none


Description:

Resets the default mouse cursor shape and sets mouse range to (0,0)-(319,199).
This function should be called just after entering mode 13h.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBresumeSound SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBresumeSound ()

Calling:

none

Returns:

none


Description:

Resume sound output paused by DQBpauseSound.

Notes:

See also DQBpauseSound


Example:

none


-----------------------------------------------------------------------------
DQBrPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBrPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL Angle, BYVAL Zoom)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   Angle       Rotation angle ranging 0-255
˛   Zoom        Zoom factor

Returns:

none


Description:

DQBrPut draws a sprite rotated and scaled of the specified values. The angle
can range from 0 to 255 (256=0), while the zoom factor represents the zooming
percentage: a value of 100 will draw the sprite in its original size, a value
of 50 will draw a sprite of half its original size, etc... The rotation uses
a pixel-perfect algorithm, but rotated pixels that lie outside the original
sprite mask will not be drawn; this means that if you want to rotate a sprite
without loosing graphics, you must get it into a bigger area. For example,
let's suppose you have a 16x16 pixels sprite: you should get an area of 22x22
pixels to be sure not to loose any pixel when rotating. The same goes when
zooming in: the original sprite area is respected.

Notes:

DQBrPut supports clipping and transparency. See also DQBput, DQBfPut, DQBsPut
and DQBbPut.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Let's use an 80x80 pixels sprite
Size = DQBsize(0, 0, 79, 79)
' Our array is made of INTEGERs, so we divide Size by 2
DIM Sprite(Size \ 2)

' Let's prepare our sprite
DQBclearLayer 1
DQBprint 1, "DirectQB!", 8, 36, 40
DQBget 1, 0, 0, 79, 79, VARSEG(Sprite(0)), VARPTR(Sprite(0))

DQBinitVGA

FOR i = 0 TO 90

  ' Empties layer 1
  DQBclearLayer 1

  ' Draws our roto-zoomed sprite into layer 1
  DQBrPut 1, 120, 60, VARSEG(Sprite(0)), VARPTR(Sprite(0)), (90 - i), (10 + i)

  ' Waits for vertical retrace 1 time
  DQBwait 1

  ' Copies layer 1 onto the screen
  DQBcopyLayer 1, VIDEO

NEXT i

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBsaveBMap FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBsaveBMap (BMap AS INTEGER, FileName AS STRING)

Calling:

˛   BMap        Number of the blender map to save
˛   FileName    Blender map file name with full extension

Returns:

An INTEGER value holding the saving results:

>   0     Operation successful
>   1     Blender map not yet created
>   2     Cannot create file or disk error
>   3     Unable to write data or disk full


Description:

This function saves the specified blender map data to disk. The bmap can be
then loaded again in memory by calling DQBloadBMap.

Notes:

See also DQBcreateBMap, DQBloadBMap


Example:

none


-----------------------------------------------------------------------------
DQBsaveImage FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBsaveImage (Layer AS INTEGER, x1 AS INTEGER, y1 AS INTEGER,
                               x2 AS INTEGER, y2 AS INTEGER, FileName AS
                               STRING, Pal AS STRING, Format AS INTEGER)

Calling:

˛   Layer       Layer where is the image to save
˛   x1          x coordinate of upper-left area of layer to save
˛   y1          y coordinate of upper-left area of layer to save
˛   x2          x coordinate of lower-right area of layer to save
˛   y2          y coordinate of lower-right area of layer to save
˛   FileName    New image file name with full extension
˛   Pal         String holding the palette to save
˛   Format      Image file format

Returns:

An INTEGER value holding the saving results:

>   0     Operation successful
>   1     Cannot create file or disk error
>   2     Unable to write data or disk full


Description:

Call this function to save an area of a layer to a file. Images can be saved
in three different formats: BSAVE compatible, BMP or PCX. When saving in the
BSAVE format, you can load the image by simply calling the QB command BLOAD,
and the palette will be appended to the end of the file. In addition, BSAVEd
images are large files, but they're the fastest to load. When using the BMP
format, the resulting file will be even larger, but you'll have a image saved
into a standard file format, editable by most of the commercial image-editing
programs. PCX is the smallest available file format, and contains the palette,
but it's also the slowest to load. The palette to save with the file must have
been previously stored into a string as explained into appendix A, by calling
DQBgetPal or even DQBloadLayer. This is done to allow saving hidden layers
with a palette different from the current one.

Notes:

When you're saving in the BSAVE format an image that's 320x200 pixels, it'll
be saved just like the QB command

              DEF SEG = <layerseg>: BSAVE <imagefile>, 0, 64000

So you'll be able to load it on the screen without requiring an intermediate
buffer. On the other hand, if you use the BSAVE format to save an image that's
smaller than 320x200, it'll be like if you used

                       GET (x1, y1)-(x2, y2), <array>
   DEF SEG = VARSEG(<array>): BSAVE <imagefile>, VARPTR(<array>), <length>

In both cases, the palette will be appended to the file; but don't worry,
because BLOAD will be still able to load your images - though without loading
the appended palette.


Example:

none


-----------------------------------------------------------------------------
DQBscroll SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBscroll (BYVAL Layer, BYVAL dx, BYVAL dy)

Calling:

˛   Layer       Layer to be scrolled
˛   dx          Horizontal scrolling offset
˛   dy          Vertical scrolling offset

Returns:

none


Description:

Scrolls selected layer. A positive dx value will scroll the layer right, a
negative one will scroll it left. Positive dy value scrolls down, negative up;
by combining these parameters you can scroll the layer in any direction. The
newly visible area will be filled with garbage, to it's up to the programmer
to fill it with new graphics.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBscrollArea SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBscrollArea (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2,
                           BYVAL y2, BYVAL Direction)

Calling:

˛   Layer       Layer to be scrolled
˛   x1          x coordinate of upper-left corner of area to scroll
˛   y1          y coordinate of upper-left corner of area to scroll
˛   x2          x coordinate of lower-right corner of area to scroll
˛   y2          y coordinate of lower-right corner of area to scroll
˛   Direction   Scrolling direction

Returns:

none


Description:

Scrolls a specified area on a given layer. The area can be scrolled only by
one pixel at a time, and the direction parameter can range from 0 to 3,
representing up, down, left and right scrolling. You can use the UP, DOWN,
LEFT and RIGHT constants defined into the DIRECTQB.BI file for ease.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetBaseLayer FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBsetBaseLayer (BYVAL Layer)

Calling:

˛   Layer       Layer in conventional memory to allocate

Returns:

0 if base layer was already allocated or there's not enough free conventional
memory, otherwise the segment of the new memory block used as layer.


Description:

DQBsetBaseLayer tryes to allocate conventional memory for a new base layer,
as specified by the Layer parameter. If successfull, this function returns
a segment address to the allocated memory chunk used as layer, which is
exactly 64000 bytes; then you can refer to this layer as you do with normal
layers in EMS memory.

Notes:

Keep in mind that base layers requires a lot of base memory, but they're
accessed a lot faster than normal EMS layers.
Also, before calling DQBsetBaseLayer you should free 64K of conventional
memory by calling the QB function SETMEM, as you do with DQBcreateBMap.
To refer to base layers you should always use the B0..B9 constants as
explained in appendix A.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Releases memory for a base layer
dummy& = SETMEM(-66000)

' Assign our array to base layer 0
Seg0 = DQBsetBaseLayer(B0)
IF Seg0 = 0 THEN
    ' Not enough memory
    DQBclose
    PRINT DQBerror$
    END
ELSE
    ' Prints some info
    PRINT "Layer allocated at address " + HEX$(Seg0) + ":0000"
    WHILE INKEY$ = "": WEND
END IF

DQBinitVGA

' Let's print some text on layer B0
DQBprint B0, "DirectQB!", 124, 96, 40

' Copy layer B0 to the screen
DQBcopyLayer B0, VIDEO

' Wait for the user to press a key...
WHILE INKEY$ = "": WEND

' Ends program
DQBclose
dummy& = SETMEM(66000)

*****************************************************************************


-----------------------------------------------------------------------------
DQBsetBIOSfont SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetBIOSfont ()

Calling:

none

Returns:

none


Description:

Resets the current font to the standard VGA BIOS one. Nexts calls to DQBprint
will use the BIOS font.

Notes:

none


Example:

See DQBprint example


-----------------------------------------------------------------------------
DQBsetBit FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBsetBit (BYVAL Value, BYVAL Bit)

Calling:

˛   Value       INTEGER variable to set bit of
˛   Bit         Bit number to set, ranging 0-15

Returns:

An INTEGER value representing the old variable value with the new bit set


Description:

Call this function to set a bit of a specified variable. This can be useful
to create boolean variables.

Notes:

See DQBresetBit, DQBreadBit and DQBtoggleBit


Example:

none


-----------------------------------------------------------------------------
DQBsetBMap SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetBMap (BYVAL BMap, BYVAL ForeCol, BYVAL BackCol, BYVAL NewCol)

Calling:

˛   BMap        BMap number to edit
˛   ForeCol     Foreground color
˛   BackCol     Background color
˛   NewCol      Color of the resulting combination

Returns:

none


Description:

Sets a color for the specified combination on the specified blender map. Never
try to set the combinations for an unmapped foreground color!

Notes:

See also DQBcreateBMap, DQBgetBMap, DQBloadBMap and DQBsaveBMap


Example:

See DQBbPut example


-----------------------------------------------------------------------------
DQBsetClipBox SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetClipBox (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)

Calling:

˛   x1          Upper left corner x coordinate of clipping box
˛   y1          Upper left corner y coordinate of clipping box
˛   x2          Lower right corner x coordinate of clipping box
˛   y2          Lower right corner y coordinate of clipping box

Returns:

none


Description:

Sets the current clipping box to (x1,y1)-(x2,y2). Next calls to all the
drawing functions (except DQBbox and DQBboxf) will be affected by the new
clipping box.

Notes:

The clipping box is set to (0,0)-(319,199) at startup.


Example:

none


-----------------------------------------------------------------------------
DQBsetCol SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetCol (BYVAL Col, BYVAL Red, BYVAL Green, BYVAL Blue)

Calling:

˛   Col         Color to change
˛   Red         New red hue
˛   Green       New green hue
˛   Blue        New blue hue

Returns:

none


Description:

Sets the hues of a given color index. The red, green and blue hues must be in
the range 0-63.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetCollideMethod SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetCollideMethod (BYVAL Method)

Calling:

˛   Method      Collision detection method to be used

Returns:

none


Description:

Sets the collision detection method to be used by the DQBcollide function.
The method parameter can be 0 (bounding box check) or 1 (pixel-perfect check);
you can use the BOX and PIXEL constants for ease.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetDrive SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetDrive (Drive AS STRING)

Calling:

˛   Drive       New drive letter

Returns:

none


Description:

This function changes the current drive to the new one specified by the letter
of the Drive parameter.

Notes:

See also DQBdrive$, DQBchDir, DQBdir$, DQBpath$, DQBnumDrives


Example:

none


-----------------------------------------------------------------------------
DQBsetFont SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetFont (Font AS STRING)

Calling:

˛   Font        String of 2305 characters holding the new font data

Returns:

none


Description:

Sets the current font to specified one held into the Font string (see appendix
C for details on the font data format). Next calls to DQBprint or DQBprints
will use the new font to draw characters.

Notes:

You can use DirectQB Tools to create your own fonts. See also DQBsetBIOSfont


Example:

none


-----------------------------------------------------------------------------
DQBsetFontTexture SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetFontTexture (BYVAL TextSeg, BYVAL TextOff)

Calling:

˛   TextSeg     Segment of the array holding the texture sprite (use VARSEG)
˛   TextOff     Offset of the array holding the texture sprite (use VARPTR)

Returns:

none


Description:

Sets the texture to be used whenever the TEXTURED font style is used. Font
textures must be normal sprites got with GET or DQBget, but their size must
always be 8x8 pixels, otherwise you may end up with unpredictable effects.
Specified texture is then used to fill the active pixels of each character of
your string.

Notes:

Textures used as font textures do not support transparency. Also, the TEXTURED
style does not work when applied together with the BOLD one, due to internal
library limitations. If you apply this combination anyway, the BOLD effect
will not be considered (but the other effects will still work!).


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Dimension our 8x8 pixels texture array
DIM Texture(35)

' Let's initialize the library with one extra layer and no sounds nor EMS
IF DQBinit(1, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Prepares the sprite that will be used as font texture on layer 1
FOR i = 0 TO 7
  DQBline 1, 0, i, i, 0, (31 - i)
NEXT i
FOR i = 0 TO 7
  DQBline 1, 7, i, i, 7, (24 - i)
NEXT i

' Get the sprite!
DQBget 1, 0, 0, 7, 7, VARSEG(Texture(0)), VARPTR(Texture(0))

' Let's set the font texture to our new one
DQBsetFontTexture VARSEG(Texture(0)), VARPTR(Texture(0))

' Prints a string on the screen
DQBprints VIDEO, "This is a textured font test!!", 0, 100, 15, TEXTURED

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose
END

*****************************************************************************


-----------------------------------------------------------------------------
DQBsetFrameRate SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetFrameRate (BYVAL FPS)

Calling:

˛   FPS         new frames per second selection

Returns:

none


Description:

Sets a new framerate. Together with the DQBframeReady function, this one can
be used to syncronize the graphics speed to a specified framerate, in an
independent way from the program complexity.

Notes:

DQBsetFrameRate alters the PC timer speed, so use caution when calling this
function; it may not be compatible with some TSR, like SBMIDI, so be warned.
See also DQBframeReady


Example:

none


-----------------------------------------------------------------------------
DQBsetMousePos SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetMousePos (BYVAL x, BYVAL y)

Calling:

˛   x           x coordinate of new mouse position
˛   y           y coordinate of new mouse position

Returns:

none


Description:

Sets the new mouse position to (x,y).

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetMouseRange SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetMouseRange (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)

Calling:

˛   x1          Upper left corner x coordinate of new range box
˛   y1          Upper left corner y coordinate of new range box
˛   x2          Lower right corner x coordinate of new range box
˛   y2          Lower right corner y coordinate of new range box

Returns:

none


Description:

Sets the new mouse range to (x1,y1)-(x2,y2).

Notes:

Mouse range is set to (0,0)-(319,199) at startup.


Example:

none


-----------------------------------------------------------------------------
DQBsetMouseShape SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetMouseShape (hotX AS INTEGER, hotY AS INTEGER, Shape AS
                              STRING)

Calling:

˛   hotX        New cursor x hotspot coordinate
˛   hotY        New cursor y hotspot coordinate
˛   Shape       New cursor shape data string

Returns:

none


Description:

Sets the new cursor shape to specified one. There's no need to hide the mouse
before calling this function, and then to show it again after the operation,
as this is automatically done for you by this function. See appendix C for
details on the mouse cursor shape data format.

Notes:

Call DQBresetMouse to restore the default mouse cursor shape. This will also
reset the mouse range box to (0,0)-(319,199), so be warned.


Example:

none


-----------------------------------------------------------------------------
DQBsetMouseSpeed SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetMouseSpeed (BYVAL Hor, BYVAL Ver)

Calling:

˛   Hor         New horizontal mouse speed
˛   Ver         New vertical mouse speed

Returns:

none


Description:

Sets the new mouse horizontal and vertical speed. By default, both speeds are
set to 16; smaller values will make the mouse movement faster, bigger values
will have the opposite effect.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetPal SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetPal (Pal AS STRING)

Calling:

˛   Pal         New palette data string

Returns:

none


Description:

Sets the current palette to the new specified one. See appendix C for details
on the palette data format.

Notes:

See also DQBgetPal


Example:

See DQBfadeTo example


-----------------------------------------------------------------------------
DQBsetSolidPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetSolidPut ()

Calling:

none

Returns:

none


Description:

Sets the solid put mode. Next calls to DQBput or DQBscaledPut will ignore
transparent color.

Notes:

See also DQBsetTransPut


Example:

See DQBput example


-----------------------------------------------------------------------------
DQBsetTextBackCol SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTextBackCol (BYVAL Col)

Calling:

˛   Col         New text background color

Returns:

none


Description:

Sets the current text background color; this will be used only if in solid
text mode.

Notes:

By default, the text background color is 0. See also DQBsetTextStyle and
DQBprint.


Example:

none


-----------------------------------------------------------------------------
DQBsetTextBMap SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTextBMap (BYVAL BMap)

Calling:

˛   BMap        Blender map to be used

Returns:

none


Description:

Sets the blender map to be used when the BLENDED text style is selected to
print text with DQBprint or DQBprints.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetTextSpacing SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTextSpacing (BYVAL Spacing)

Calling:

˛   Spacing     Characters extra spacing in pixel

Returns:

none


Description:

You can call this function to modify the spacing between characters drawn in
the current font with DQBprint or DQBprints. By default this value is 0 (that
means the spacing is the font default); by increasing it, you can add extra
spacing between each character printed.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBsetTextStyle SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTextStyle (BYVAL Style)

Calling:

˛   Style       New text style

Returns:

none


Description:

Sets the current text style used by DQBprint. The style is indipendent from
the current font; the available styles are bold, italic and underlined. To use
no styles just pass the NONE constant to this function. DQBsetTextStyle allows
also to set the transparent or solid text mode as well as support for color
blending and textured text; by default, the transparent mode is set, but by
passing the SOLID constant, next calls to DQBprint will print solid text. On
the other hand, to obtain blended text, just add the BLENDED constant, while
adding TEXTURED causes the current font texture to be used to print your text.
You can use combinations of all the styles, by simply adding the right
constants, that can be found in appendix A.

Notes:

The only styles combination that doesn't work is when you apply BOLD and
TEXTURED modes together. In this case, the first one is ignored. See also
DQBprint, DQBprints, DQBsetFontTexture


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Uses normal font with DQBprint
DQBprint VIDEO, "This is a normal text", 0, 0, 31

' Let's set solid italic style...
DQBsetTextStyle SOLID + ITALIC
' ...and red background color
DQBsetTextBackCol 4

' Prints something using the new style
DQBprint VIDEO, "And this is solid italic text!", 0, 50, 31

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBsetTextureSize SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTextureSize (BYVAL Size)

Calling:

˛   Size        New texture width

Returns:

none


Description:

Unlike the name says, DQBsetTextureSize is used to set only the width of the
texture used by subsequent calls to DQBttri. The width must be specified in
pixels and must be a power of 2; values that are not powers of 2 will be
rounded to the previous power, so that if you give 63 the function will assume
it's a 32, and if you give a 64, it'll assume it's a 64, etc... There are no
limits about the height of a texture, you only have to care about the texel
coordinates of the vertexes of your triangle.

Notes:

By default, the texture size is set to 64; see also DQBttri.


Example:

none


-----------------------------------------------------------------------------
DQBsetTransPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetTransPut ()

Calling:

none

Returns:

none


Description:

Sets the transparent put mode. Next calls to DQBput or DQBscaledPut will draw
transparent sprites.

Notes:

See also DQBsetSolidPut


Example:

See DQBput example


-----------------------------------------------------------------------------
DQBsetVoiceVol SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetVoiceVol (BYVAL Voice,BYVAL Volume)

Calling:

˛   Voice       Voice to change volume of
˛   Volume      New voice volume setting

Returns:

none


Description:

Sets the volume setting for a specified voice; it may range from 0 to 63.

Notes:

By default the volume setting for all the voices is 63; remember that the
volume of a voice also depends on the master volume setting. This function
has no effect if the volume table is off (see DQBinstallSB for details)


Example:

none


-----------------------------------------------------------------------------
DQBsetVolume SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsetVolume (BYVAL Volume)

Calling:

˛   Volume      New master volume setting

Returns:

none


Description:

Sets the master volume setting for sound output; it may range from 0 to 15.

Notes:

There's no default volume setting, so it is recommended that you set the
volume as you wish just after calling DQBinstallSB in your programs.

Example:

none


-----------------------------------------------------------------------------
DQBshiftLeft FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBshiftLeft (BYVAL Value, BYVAL NumBits)

Calling:

˛   Value       INTEGER value to shift
˛   NumBits     Number of bits to shift left

Returns:

An INTEGER value representing the shifted number


Description:

Performs a logical shift left of the given integer value, and returns the
result. This can be useful to multiply by powers of 2 a given number, as this
operation is faster than *.

Notes:

See also DQBshiftRight


Example:

none


-----------------------------------------------------------------------------
DQBshiftRight FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBshiftRight (BYVAL Value, BYVAL NumBits)

Calling:

˛   Value       INTEGER value to shift
˛   NumBits     Number of bits to shift right

Returns:

An INTEGER value representing the shifted number


Description:

Performs a logical shift right of the given integer value, and returns the
result. This can be useful to divide by powers of 2 a given number, as this
operation is faster than \.

Notes:

See also DQBshiftLeft


Example:

none


-----------------------------------------------------------------------------
DQBsize FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBsize (BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2)

Calling:
                
˛   x1          Upper left corner x coordinate
˛   y1          Upper left corner y coordinate
˛   x2          Lower right corner x coordinate
˛   y2          Lower right corner y coordinate

Returns:

An INTEGER value holding the sprite size in bytes


Description:

DQBsize returns the number of bytes needed to store the image contained into
the box given by (x1,y1)-(x2,y2) with DQBget. This value can be then used to
dimension arrays to store the sprite data for the DQBget and DQBput routines.
Remember that the array is made of INTEGERs while this function returns the
number of bytes; just divide its result by 2 to obtain the array dimension.

Notes:

This function can be useful when storing several sprites into the same array,
to know the exact offset of each frame.


Example:

See DQBput example


-----------------------------------------------------------------------------
DQBsort SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsort (BYVAL ArraySeg, BYVAL ArrayOff, BYVAL NumRecords,
                     BYVAL RecordLen, IndexOff)

Calling:
                
˛   ArraySeg    Segment of the array of integers to sort; use VARSEG
˛   ArrayOff    Offset of the array of integers to sort; use VARPTR
˛   NumRecords  Total number of records to sort
˛   RecordLen   Length of each record in bytes
˛   IndexOff    Offset of the integer index value within a record

Returns:

none


Description:

DQBsort uses a fast bubble sort algorithm to sort a given array of records,
by comparing the index number (that must be an integer) of each record and
sorting the correspondent records from the lower value to the higher one of
it. The index field can be anywhere within the record, and you can specify
its position by using the IndexOff parameter, that is relative to the
beginning of a record (i.e. IndexOff=0 means the first field of a it).
RecordLen is the number of bytes of each record.

Notes:

A record can contain any type of data, and DQBsort will sort it by comparing
the index numbers. You can also sort a simple array of integers, by passing
2 as RecordLen (an integer is 2 bytes long) and 0 as IndexOff.


Example:

none


-----------------------------------------------------------------------------
DQBsPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBsPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL NewWidth, BYVAL NewHeight)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   NewWidth    New sprite width in pixel units
˛   NewHeight   New sprite height in pixel units

Returns:

none


Description:

DQBsPut works like DQBput, but allows to draw a scaled version of your sprite,
by specifying its new width and height; the sprite data is not modified during
this operation. This function also supports clipping and transparency.

Notes:

See DQBput, DQBfPut, DQBrPut and DQBbPut


Example:

See DQBput example


-----------------------------------------------------------------------------
DQBstopVoice SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBstopVoice (BYVAL Voice)

Calling:
                
˛   Voice       Voice to stop

Returns:

none


Description:

Stops any sound coming from specified voice; you can use this to stop a
looping sample...

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBtoggleBit FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBtoggleBit (BYVAL Value, BYVAL Bit)

Calling:

˛   Value       INTEGER value to toggle bit of
˛   Bit         Bit number to toggle

Returns:

An INTEGER value representing the original number with specified bit toggled.


Description:

Toggles specified bit of the given number, and returns the result.

Notes:

See also DQBsetBit, DQBresetBit and DQBreadBit


Example:

none


-----------------------------------------------------------------------------
DQBtPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBtPut (BYVAL Layer, BYVAL x, BYVAL y, BYVAL SpriteSeg,
                     BYVAL SpriteOff, BYVAL BitMode)

Calling:

˛   Layer       Layer where to draw the sprite
˛   x           X position of upper left corner of the sprite
˛   y           Y position of upper left corner of the sprite
˛   SpriteSeg   Segment of the array holding the sprite data; use VARSEG
˛   SpriteOff   Offset of the array holding the sprite data; use VARPTR
˛   BitMode     Specifies which bitwise operation to perform

Returns:

none


Description:

As normal DQBput, this routine draws a sprite on the given layer; but DQBtPut
allows you to apply a specified bitwise operation between each pixel of your
sprite and the background. Allowed modes are AND, OR and XOR, represented by
the numbers 1, 2 and 3 (you can use the BIT.AND, BIT.OR and BIT.XOR constants
here - see appendix A for a complete list of DQB constants). This function
supports both transparency and clipping.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBtri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBtri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                    BYVAL x3, BYVAL y3, BYVAL Col)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   Col         color


Returns:

none


Description:

Draws a flat-shaded triangle with (x1,y1), (x2,y2) and (x3,y3) as vertex,
filled with specified color. DQBtri does not support transparency, but it's
affected by the clipping box.

Notes:

See also DQBgtri


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Draws 500 flat-shaded triangles
FOR i = 1 TO 500
  DQBtri VIDEO, (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 256)
NEXT i

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBttri SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBttri (BYVAL Layer, BYVAL x1, BYVAL y1, BYVAL x2, BYVAL y2,
                     BYVAL x3, BYVAL y3, BYVAL u1, BYVAL v1, BYVAL u2,
                     BYVAL v2, BYVAL u3, BYVAL v3, BYVAL TextureSeg,
                     BYVAL TextureOff)

Calling:

˛   Layer       Layer where to draw the triangle
˛   x1          x coordinate of the first vertex
˛   y1          y coordinate of the first vertex
˛   x2          x coordinate of the second vertex
˛   y2          y coordinate of the second vertex
˛   x3          x coordinate of the third vertex
˛   y3          y coordinate of the third vertex
˛   u1          x coordinate of first vertex on texture
˛   v1          y coordinate of first vertex on texture
˛   u2          x coordinate of second vertex on texture
˛   v2          y coordinate of second vertex on texture
˛   u3          x coordinate of third vertex on texture
˛   v3          y coordinate of third vertex on texture
˛   TextureSeg  Array segment holding the texture (use VARSEG)
˛   TextureOff  Array offset holding the texture (use VARPTR)


Returns:

none


Description:

Draws a texture-mapped triangle with (x1,y1), (x2,y2) and (x3,y3) as vertexes.
The texture used must be stored into specified array with GET or DQBget, and
its width must be a power of 2, equal to the one specified by calling
DQBsetTextureSize (the default texture width is 64 pixels). Each vertex of
the triangle has also its own texture coordinates, that can be anywhere on
the texture itself, as well as out of it; if the distance between two texture
vertexes is greater than the texture size, the texture is wrapped while
drawing. DQBttri supports transparency (color 0 on the texture is *always*
handled as transparent color) and clipping.

Notes:

See also DQBsetTextureSize, DQBtri, DQBbtri, DQBgtri


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Dimension our 64x64 pixels texture array
DIM Texture(2049)

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

DQBinitVGA

' Let's build our sample texture
FOR i = 0 TO 15
  DQBbox VIDEO, i, i, 63 - i, 63 - i, 31 - i
  DQBbox VIDEO, 16 + i, 16 + i, 47 - i, 47 - i, 16 + i
NEXT i
DQBbox VIDEO, 0, 0, 63, 63, 40
DQBline VIDEO, 0, 0, 63, 63, 4
DQBellipse VIDEO, 32, 32, 24, 24, 43

' Gets our texture and clears the screen
DQBget VIDEO, 0, 0, 63, 63, VARSEG(Texture(0)), VARPTR(Texture(0))
DQBclearLayer VIDEO

' Draws 500 textured triangles
FOR i = 1 TO 500
  DQBttri VIDEO, (RND * 320), (RND * 200), (RND * 320), (RND * 200), (RND * 320), (RND * 200), 0, 0, 63, 0, 0, 63, VARSEG(Texture(0)), VARPTR(Texture(0))
NEXT i

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBunpackBMap FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackBMap (BYVAL PacketID, BYVAL BMap)

Calling:

˛   PacketID    Packet ID number
˛   BMap        Blender map to load data into

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data
>   4     Blender map is not active
>   5     Incompatible blender map


Description:

Decodes the blender map identified by specified packet ID number from the
currently opened datafile; blender map should be compatible with the bmap
structure where you're going to decode it onto (see DQBloadBMap for details).

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackCursor FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackCursor (PacketID AS INTEGER, Cursor AS STRING)

Calling:

˛   PacketID    Packet ID number
˛   Cursor      64 characters string where to hold decoded cursor data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Decodes the mouse cursor identified by specified packet ID number from the
currently opened datafile, and stores it into the Cursor string, ready to be
used with the DQBsetMouseShape function.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackFont FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackFont (PacketID AS INTEGER, Font AS STRING)

Calling:

˛   PacketID    Packet ID number
˛   Font        2305 characters string where to hold decoded font data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Decodes the font identified by specified packet ID number from the currently
opened datafile, and stores it into the Font string, ready to be used with
the DQBsetFont function.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackImage FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackImage (BYVAL PacketID, BYVAL Layer, BYVAL x, BYVAL y)

Calling:

˛   PacketID    Packet ID number
˛   Layer       Layer where to draw the image
˛   x           x coordinate where to begin drawing
˛   y           y coordinate where to begin drawing

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Decodes the image identified by specified packet ID number from the currently
opened datafile, and draws it into the given layer, starting at (x,y). The
image packet does not include picture palette, so you'll have to set a palette
taken from another source (a palette packet from the same datafile, or any
other way you like). Also, this function does not support clipping, so it's
up to you to ensure that the image fits on the layer.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackPal FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackPal (PacketID AS INTEGER, Pal AS STRING)

Calling:

˛   PacketID    Packet ID number
˛   Pal         768 characters string to hold decoded palette data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Decodes the palette identified by specified packet ID number from the
currently opened datafile, and stores it into the Pal string. You can then
use it with all the other DQB palette handling functions.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackSound FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackSound (BYVAL PacketID, BYVAL Slot)

Calling:

˛   PacketID    Packet ID number
˛   Slot        Sound slot where to place decoded sound data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data
>   4     Unknown sound slot


Description:

Decodes the sound sample identified by specified packet ID number from the
currently opened datafile, and stores it into the given sound slot; it is
assumed that such a slot has been initialized with DQBinit. Decoded sounds
can then be normally played with DQBplaySound.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackSprite FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackSprite (BYVAL PacketID, BYVAL SpriteSeg, BYVAL
                                  SpriteOff)

Calling:

˛   PacketID    Packet ID number
˛   SpriteSeg   Segment of QB array where to hold decoded sprite data
˛   SpriteOff   Offset of QB array where to hold decoded sprite data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Acts like DQBunpackImage, but stores decoded image data into the specified
QB array, ready to be used with DQBput or similar functions. Be sure you have
an array big enough to contain the data, otherwise you may crash your system.

Notes:

This works on image packets; this means you can call DQBunpackImage as well
as DQBunpackSprite on the same image packet.


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBunpackUser FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBunpackUser (BYVAL PacketID, BYVAL DataSeg, BYVAL DataOff)

Calling:

˛   PacketID    Packet ID number
˛   DataSeg     Segment of QB array where to hold decoded user-defined data
˛   DataOff     Offset of QB array where to hold decoded user-defined data

Returns:

An INTEGER value holding the unpacking results:

>   0     Operation successful
>   1     Datafile not yet opened
>   2     Unknown packet ID number
>   3     Bad password or unknown data


Description:

Decodes an user defined packet data identified by specified packet ID number
from currently opened datafile into a QB array. User-defined packets can hold
any kind of binary data, limited only by the size, which must be 64K maximum.
The array where to place decoded data must be enough big to contain it,
otherwise you may crash your machine.

Notes:

none


Example:

See DQBopenDataFile


-----------------------------------------------------------------------------
DQBver FUNCTION
-----------------------------------------------------------------------------

Prototype:

DECLARE FUNCTION DQBver ()

Calling:

none

Returns:

An INTEGER value holding the library version


Description:

DQBver returns the current DirectQB library version into an integer value. The
higher byte represents the major version, and the lower byte the minor version
number.

Notes:

You can also use DQBid$ to retrive a small string holding the library version
and my name, in case you want to display them.


Example:

*****************************************************************************

' All integers for speed
DEFINT A-Z

'$INCLUDE:'DIRECTQB.BI'

' Let's initialize the library with no extra layers nor sounds nor EMS
IF DQBinit(0, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Finds major and minor library version numbers
major = DQBver \ &H100
minor = DQBver AND &HFF

' Prints them
PRINT "Current DirectQB version is" + STR$(major) + "." + LTRIM$(STR$(minor))

' Prints the library identification string
PRINT DQBid$

' Waits for the user to press a key
WHILE INKEY$ = "": WEND

' Ends program
DQBclose

*****************************************************************************


-----------------------------------------------------------------------------
DQBwait SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBwait (BYVAL Times)

Calling:

˛   Times       Times to wait for the video vertical retrace

Returns:

none


Description:

Waits for the video vertical retrace Times times. It is suggested to wait for
the vertical retrace a time before drawing anything on the screen: this will
produce flickerless animations. The vertical retrace occurs 60 times per
second, so you can use this function also as delay routine.

Notes:

none


Example:

none


-----------------------------------------------------------------------------
DQBwaitKey SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBwaitKey (BYVAL ScanCode)

Calling:

˛   Scancode    Scancode of the key to wait for

Returns:

none


Description:

Waits for the user to press the key specified by the scancode passed to the
function. DQBwaitKey works only if the keyboard interrupt handler has been
installed by calling DQBinstallKeyboard.

Notes:

See DQBinstallKeyboard, DQBkey, DQBreadKey


Example:

none


-----------------------------------------------------------------------------
DQBxPut SUB
-----------------------------------------------------------------------------

Prototype:

DECLARE SUB DQBxPut (BYVAL SourceLayer, BYVAL x1, BYVAL y1, BYVAL x2,
                     BYVAL y2, BYVAL DestLayer, BYVAL x, BYVAL y)

Calling:

˛   SourceLayer   Layer where to get the sprite (source)
˛   x1            x position of upper left corner of the sprite on source
˛   y1            y position of upper left corner of the sprite on source
˛   x2            x position of lower right corner of the sprite on source
˛   y2            y position of lower right corner of the sprite on source
˛   DestLayer     Layer where to draw the sprite (destination)
˛   x             x position of upper left corner of the sprite on destination
˛   y             y position of upper left corner of the sprite on destination

Returns:

none


Description:

Like normal DQBput, this function draws a sprite onto a specified layer, but
with a huge difference: DQBxPut does not require that you first get your
sprite into a QB array, as it automatically gets the data by assuming you
want to draw the sprite contained into the (x1,y1)-(x2,y2) box on the source
layer. Sprite data is directly copied into the destination layer at specified
(x,y) coordinates; this is great, but it has its weak spots... When both the
source and destination layers are on EMS, DQBxPut is slower than DQBput; in
addition it can only handle sprites with a height up to 50 pixels: higher
sprites will not be drawn (but there are no limits for the width).

Notes:

DQBxPut supports transparency and it's affected by the clipping box, so pixels
outside this box will not be drawn. It is strongly suggested that you use this
function to draw from an EMS layer onto a layer in base memory; this way you
can achieve almost the same speed of DQBput, without the need of extra memory
to hold the sprite. See also DQBput, DQBfPut, DQBsPut, DQBrPut and DQBbPut.


Example:

*****************************************************************************

' Here's a modified version of the DQBput example; this time we'll not use
' arrays to store our sprites...

' All integers for speed
DEFINT A-Z

'$INCLUDE: 'DIRECTQB.BI'

' Let's initialize the library with two extra layers and no sounds nor EMS
IF DQBinit(2, 0, 0) THEN DQBclose: PRINT DQBerror$: END

' Let's prepare our sprites on layer 2
FOR i = 0 TO 14

  ' Draws a frame of our sprite
  DQBbox 2, (i * 16), 0, (i * 16) + 15, 15, 4
  DQBline 2, (i * 16) + (15-i), 15, (i * 16) + i, 0, 40
  DQBline 2, (i * 16) + 15, i, (i * 16), (15 - i), 40

NEXT i

DQBinitVGA

FOR i = -16 TO 320

  ' Empties layer 1
  DQBclearLayer 1

  ' Finds what frame to draw
  Frame = ((i + 16) \ 2) MOD 15

  ' Draws our frame into layer 1
  DQBxPut 2, (Frame * 16), 0, (Frame * 16) + 15, 15, 1, i, 92

  ' Waits for vertical retrace 1 time
  DQBwait 1

  ' Copies layer 1 onto the screen
  DQBcopyLayer 1, VIDEO

NEXT i

' Ends program
DQBclose

*****************************************************************************


=============================================================================
APPENDIX A - Library constants
=============================================================================

To simplify the use of certain functions, the file DIRECTQB.BI contains some
useful constants. Here's the list:

Constant name     Value   Can be used by
-----------------------------------------------------------------------------
TRUE              -1      General purpose, no specific function
FALSE             0       General purpose, no specific function
VIDEO             0       All the graphical functions that refer to a layer
B0                &H8000  All graphical functions to refer to 1st base layer
B1                &H8001  All graphical functions to refer to 2nd base layer
B2..B9     &H8002-&H8009  All graphical functions to refer to base layers 3-10
BSV               0       DQBsaveLayer to specify to save in BSAVE format
BMP               1       DQBsaveLayer to specify to save in BMP format
PCX               2       DQBsaveLayer to specify to save in PCX format
HOR               1       DQBmPut to draw horizontally flipped sprites
VER               2       DQBmPut to draw vertically flipped sprites
BIT.AND           1       DQBtPut to use AND bitwise operation between pixels
BIT.OR            2       DQBtPut to use OR bitwise operation between pixels
BIT.XOR           3       DQBtPut to use XOR bitwise operation between pixels
BOX               0       DQBsetCollideMethod to set bounding box check
PIXEL             1       DQBsetCollideMethod to set pixel-perfect check
FORWARD           0       DQBrotatePal to rotate palette forward
BACKWARD          1       DQBrotatePal to rotate palette backward
CENTERED          &H8000  DQBprint and DQBprints to center text on the screen
NONE              0       DQBsetTextStyle, DQBprints to specify no styles
SOLID             1       DQBsetTextStyle, DQBprints to specify solid style
BOLD              2       DQBsetTextStyle, DQBprints to specify bold style
ITALIC            4       DQBsetTextStyle, DQBprints to specify italic style
UNDERLINED        8       DQBsetTextStyle, DQBprints to specify underlined st.
BLENDED           16      DQBsetTextStyle, DQBprints to specify blended style
TEXTURED          32      DQBsetTextStyle, DQBprints to specify textured style
KEYANY            -1      DQBplayFLI, DQBwaitKey to specify any key
KEYESC            1       DQBkey to check the ESC key (see appendix B)
KEYENTER          28      DQBkey to check the ENTER key (see appendix B)
KEYSPACE          57      DQBkey to check the SPACE key (see appendix B)
KEYUP             72      DQBkey to check the up arrow key (see appendix B)
KEYDOWN           80      DQBkey to check the down arrow key (see appendix B)
KEYLEFT           75      DQBkey to check the left arrow key (see appendix B)
KEYRIGHT          77      DQBkey to check the right arrow key (see appendix B)
UP                0       DQBjoyMove to check if the joystick is moved up
DOWN              1       DQBjoyMove to check if the joystick is moved down
LEFT              2       DQBjoyMove to check if the joystick is moved left
RIGHT             3       DQBjoyMove to check if the joystick is moved right
JOY1              0       All the joystick routines to refer to joystick 1
JOY2              1       All the joystick routines to refer to joystick 2
GAMEPAD           2       All the joystick routines to refer to 4-buttons joys
BUTA              0       DQBjoyFire to check if joystick button A is pressed
BUTB              1       DQBjoyFire to check if joystick button B is pressed
BUTC              2       DQBjoyFire to check if gamepad button C is pressed
BUTD              3       DQBjoyFire to check if gamepad button D is pressed
AUTO              -1      DQBinstallSB to autodetect the soundcard settings
ONCE              0       DQBplaySound to play a sound once
LOOPED            1       DQBplaySound to play a sound repeatedly
ATTRIB.R          &H1     DQBdir$ attribute to search for read-only files
ATTRIB.H          &H2     DQBdir$ attribute to search for hidden files
ATTRIB.S          &H4     DQBdir$ attribute to search for system files
ATTRIB.L          &H8     DQBdir$ attribute to search for volume labels
ATTRIB.D          &H10    DQBdir$ attribute to search for directories
ATTRIB.A          &H20    DQBdir$ attribute to search for archive files


=============================================================================
APPENDIX B - Keyboard scancodes list
=============================================================================

To check the state (pressed or released) of a certain key with the DQBkey
function, you must pass its keyboard scancode as parameter. For the most used
keys there're some constants that help you, so check out appendix A.
For the other keys, here's the complete list of scancodes for all them (please
note that a single scancode can represent more than a single key):

Scancode  Key                           Scancode  Key
-----------------------------------------------------------------------------
 1        ESC                           44        Z
 2        1                             45        X
 3        2                             46        C
 4        3                             47        V
 5        4                             48        B
 6        5                             49        N
 7        6                             50        M
 8        7                             51        , or <
 9        8                             52        . or >
10        9                             53        / or ?
11        0                             54        RIGHT SHIFT
12        - or _                        55        * or PRINT SCREEN
13        = or +                        56        ALT (RIGHT and LEFT)
14        BACKSPACE                     57        SPACE
15        TAB                           58        CAPSLOCK
16        Q                             59        F1
17        W                             60        F2
18        E                             61        F3
19        R                             62        F4
20        T                             63        F5
21        Y                             64        F6
22        U                             65        F7
23        I                             66        F8
24        O                             67        F9
25        P                             68        F10
26        [ or {                        69        NUMLOCK
27        ] or }                        70        SCROLL LOCK
28        ENTER                         71        7 or HOME
29        CONTROL (RIGHT and LEFT)      72        8 or UP
30        A                             73        9 or PAGE UP
31        S                             74        -
32        D                             75        4 or LEFT
33        F                             76        5
34        G                             77        6 or RIGHT
35        H                             78        +
36        J                             79        1 or END
37        K                             80        2 or DOWN
38        L                             81        3 or PAGE DOWN
39        ; or :                        82        0 or INSERT
40        ' or "                        83        . or DEL
41        \ or ~                        87        F11
42        LEFT SHIFT                    88        F12


=============================================================================
APPENDIX C - Library file formats
=============================================================================

-----------------------------------------------------------------------------
The palette data format
-----------------------------------------------------------------------------

The palette parameter used by DQBsetPal, DQBgetPal, DQBfadeIn, DQBloadLayer
and DQBsaveLayer must be a string of 768 character. This string holds the
hues data for each of the 256 colors: three bytes per color, representing
the red, green and blue intensities ranging 0-63. So if you want to know the
green intesity of color 45 of given palette stored into the Pal string, here's
the simple code:

green = ASC(MID$(Pal, ((45 * 3) + 2), 1))
                        |         |
                        |          \ Change this with 1,2 or 3 to know the
                        |            red, green and blue hues
                         \ This is the color number; let's multiply it by 3
                          

-----------------------------------------------------------------------------
The mouse cursor data format
-----------------------------------------------------------------------------

When calling DQBsetMouseShape, you must pass a string of 64 characters as the
third parameter; this represents the cursor shape data.
Each cursor shape is a 16x16 pixels bitmap, composed of two masks of bits: the
so called "screen mask" and "cursor mask". The data is stored so that the
first 32 bytes of our string are the screen mask, and the other 32 are the
cursor mask. Two bytes (16 bits) make a cursor line, so we have 64 bytes
to define the two 16x16 pixels masks.
The screen mask specifies what part of the cursor is to be the shape and what
part is to be the background: a 0 means the background, a 1 means the shape.
The cursor mask tells what color to use into the mask. By combining these two
masks, the cursor is drawn onto the screen. Here are the combinations, with
their results on the screen:

Bit on screen mask            Bit on cursor mask          Pixel drawn
0                             0                           Black
0                             1                           White
1                             0                           Transparent
1                             1                           Inverted

I know it's hard, but it's even harder to explain... I'll try to make an
example. Let's look at the data below: this represents the default DirectQB
mouse cursor (the arrow).

&HFF,&H3F,&HFF,&H1F,&HFF,&H0F,&HFF,&H07     \
&HFF,&H03,&HFF,&H01,&HFF,&H00,&H7F,&H00      |
&H3F,&H00,&H7F,&H00,&HFF,&H0F,&HFF,&HBF      |--- Screen mask
&HFF,&HFF,&HFF,&HFF,&HFF,&HFF,&HFF,&HFF     /
&H00,&H00,&H00,&H40,&H00,&H60,&H00,&H70     \
&H00,&H78,&H00,&H7C,&H00,&H7E,&H00,&H7F      |
&H80,&H7F,&H00,&H70,&H00,&H40,&H00,&H00      |--- Cursor mask
&H00,&H00,&H00,&H00,&H00,&H00,&H00,&H00     /

Let's examine the bytes of our masks: just remember that of the two bytes that
make a cursor line, the first represents the last 8 pixels, and the second the
first 8.

Screen mask                             Cursor mask

&HFF,&H3F =   0011111111111111          &H00,&H00 =   0000000000000000
&HFF,&H1F =   0001111111111111          &H00,&H40 =   0100000000000000
&HFF,&H0F =   0000111111111111          &H00,&H60 =   0110000000000000
&HFF,&H07 =   0000011111111111          &H00,&H70 =   0111000000000000
&HFF,&H03 =   0000001111111111          &H00,&H78 =   0111100000000000
&HFF,&H01 =   0000000111111111          &H00,&H7C =   0111110000000000
&HFF,&H00 =   0000000011111111          &H00,&H7E =   0111111000000000
&H7F,&H00 =   0000000001111111          &H00,&H7F =   0111111100000000
&H3F,&H00 =   0000000000111111          &H80,&H7F =   0111111110000000
&H7F,&H00 =   0000000001111111          &H00,&H70 =   0111000000000000
&HFF,&H0F =   0000111111111111          &H00,&H40 =   0100000000000000
&HFF,&HBF =   1011111111111111          &H00,&H00 =   0000000000000000
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000
&HFF,&HFF =   1111111111111111          &H00,&H00 =   0000000000000000

The hotspot is passed to DQBsetMouseShape in pixel units. A hotspot of (0,0)
represents the upper-left corner of the cursor bitmap; the hotspot coordinates
can range from (-16,-16) to (16,16).

Now I know that it's not so easy to create a mouse cursor, so I made the
CUREDIT program, which is a cursor editor. You can use it to create and save
your cursors as DATA statements as well as into a binary file as strings of
64 characters.


-----------------------------------------------------------------------------
The font data format
-----------------------------------------------------------------------------

A font is contained into a string of 2305 characters. Each font holds the
graphical data for 256 characters (8 bytes per each character, so we have
8*256=the first 2048 bytes), the width in pixels of each of them (next 256
bytes, 1 byte for each character), and the height of all the characters (last
byte).
Each bit of the 8 bytes of graphical data of a character represents the state
of a pixel: 1 means the pixel is on, 0 that the pixel is off.
So let's examine the data for the following character:

00010000 =  &H10
00111000 =  &H38
01101100 =  &H6C
01101100 =  &H6C
11000110 =  &HC6
11111110 =  &HFE
11000110 =  &HC6
00000000 =  &H00

This would obviously represent an 'A'...
The pixels off will be transparent if in transparent text mode, otherwise it
will be set to the current text background color set by DQBsetTextBackCol.

Old fixed-sized fonts are no longer supported by DQBsetFont.
Use DirectQB Tools to create your own fonts; old fonts can be still loaded
from this utility, so you can use it to convert them into the new format.


-----------------------------------------------------------------------------
The blender map data format
-----------------------------------------------------------------------------

Creating a blender map is often a slow process. For this reason, I've coded
the DQBloadBMap and DQBsaveBMap functions; here follows the file format
description:

Offset  Length  Description
0       4       Blender map file format ID string; must be "BMap"
4       1       First mapped foreground color
5       1       Last mapped foreground color
6       256*n   n blender map chunks, where n is the total number of mapped
                foreground colors

A blender map chunk is a 256 bytes chunk that contains all the 256 possible
background color combination for a foreground color.


-----------------------------------------------------------------------------
The datafile file format
-----------------------------------------------------------------------------

DirectQB datafiles are a little complex structures. The first 1032 bytes are
the header, here explained:

Offset  Length  Description
0       7       Datafile file format ID string: must be "DQBPaCk"
7       1       Number of used packets
8       1024    256 packet offset info chunks; each of these is a 4 bytes
                long integer, specifying the absolute address of the packet
                data into the file

Next the packets data follow. Each packet type has its own small header, and
all them are encoded and encrypted using the same algorithm: basically it's
a simple RLE-based engine, where every time a byte has to be repeated, a
255 is the marker byte, next follow the number of repetitions (up to 255), and
the byte to repeat. If a single byte 255 has to decoded, the encoded stream
would look like "255,1,255"; that's all. About encryption, here's how it
works: before RLE-decoding the data stream, the password bytes are
"subtracted" from the encoded data, and this is repeated beginning with
subtracting the first password character to the first packet byte, and then
until the end of the packet, wrapping the password. Needless to say, when
no password is specified, this process has no effect. The password is not
stored into the datafile itself, so it's up to you to remind it, otherwise
you may loose your data! I know this is also a simple algorithm, but it works
quickly and it's hard to decode.
Now, here follows an explanation of the different packets allowed into a
datafile. I refer to them as they should be once decrypted and decoded:

* FONT packet

    Offset  Length  Description
    0       4       Packet ID: must be "FNT˛"
    4       2305    Font data

* IMAGE packet

    Offset  Length  Description
    0       4       Packet ID: must be "IMG˛"
    4       2       Image width in pixels
    6       2       Image height in pixels
    8       ?       Image data

* SOUND packet

    Offset  Length  Description
    0       4       Packet ID: must be "SND˛"
    4       4       Sound length in bytes
    8       ?       Sample data

* PALETTE packet

    Offset  Length  Description
    0       4       Packet ID: must be "PAL˛"
    4       768     Palette data

* BMAP packet

    Offset  Length  Description
    0       4       Packet ID: must be "BMA˛"
    4       1       Number of mapped foreground color
    5       ?       Blender map data

* CURSOR packet

    Offset  Length  Description
    0       4       Packet ID: must be "CUR˛"
    4       64      Cursor data

* USER packet

    Offset  Length  Description
    0       4       Packet ID: must be "USR˛"
    4       4       Data length
    8       ?       Any data



=============================================================================
APPENDIX D - Known bugs
=============================================================================

I've worked a lot to fix all the possible bugs of this library. Anyway I'm
not sure DirectQB is totally bug-free.
The main "bug" I've found is with the mouse initialization when calling
DQBinit. Sometimes on my K6-200 it locks up the machine, and you have to
reboot; this seems not to happen on my notebook with external mouse (Logitech),
so I'm supposing it's a mouse driver problem, also because theoretically my
code should work...
Again about the mouse, I've reported that the hotspot setting when calling
DQBsetMouseShape fails under Windows 95: to obtain the correct X hotspot
coordinate you must multiply your value by 2 and then pass it to the function.
This is very strange as all works ok when running the same code under plain
DOS, so I've not fixed it.
I've not found any more bugs on the library as by now; if you find others,
please let me know, and I'll try to fix them.


=============================================================================
APPENDIX E - Versions history
=============================================================================

version 1.0                 First version of DirectQB, with no sound support,
August, the 30th 1998       a mouse cursor editor plus a demo of the library.
                            DQBget and DQBput use a custom sprite data format,
                            which is not compatible with standard GET and PUT.

version 1.1                 After a month of waitings, version 1.1 brings a
October, the 3rd 1998       limited sound support, as only a sound effect can
                            be played at once. Sounds are stored and played
                            directly from EMS; the user just calls a function
                            to load and another one to play them. DQBget and
                            DQBput are now compatible with GET and PUT, and
                            DQBput has been optimized a lot. Also added an
                            even faster DQBfastPut, plus a DQBscaledPut
                            routines. Other functions here and there, plus a
                            working-on one to draw gouraud shaded triangles.

version 1.11                The sound engine bug has been fixed! Now you can
October, the 5th 1998       play up to 8 sound effects simultaneously!!
                            Also added customizable volume setting for each
                            of the eight voices...

version 1.2                 Added a lot of new routines. DirectQB now supports
October, the 27th 1998      roto-zooming effects, as well as color blending.
                            With the new blender map system, you can now build
                            virtually any color effect; also fixed some bugs
                            here and there, and added some extra sound handing
                            routines.

version 1.3                 Mainly internal enhancements; added an int 24h
November, the 15th 1998     handler for critical DOS errors. DQBxPut draws a
                            sprite without using external QB arrays, saving
                            memory; new faster DQBprint function now supports
                            non-fixed sized fonts, as well as different print
                            styles (normal, bold, italic, or underlined).
                            DirectQB has its first 3D functions! DQBtri and
                            DQBgtri draw flat-shaded and gouraud-shaded
                            triangles very quickly.

version 1.31                Finally added texture mapped triangle support;
November, the 23th 1998     most of the graphical functions have been
                            accelerated a little, plus other minor changes...

version 1.4                 No more DQBlite! Now the entire library is split
December, the 18th 1998     into 15 object files, so you can build your own
                            custom version of DQB, only with the functions
                            that you actually use! Added color blending
                            support to all the triangle functions, a fliped
                            put routine and support for layers in conventional
                            memory. In addition, from this release the library
                            will be shared without executables nor the LIB and
                            QLB files; anyway there's an utility that helps
                            you building these last ones.

version 1.41                Small bugfixed, and the new DQBpaint function
December, the 22nd 1998     added. Nothing more to report...

version 1.42                Another maintenance release, with lot of small
December, the 29th 1998     bugs fixed; base layers are now automatically
                            allocated in conventional memory, and finally they
                            work... Also added two new joystick routines, and
                            the MAKEDQB utility have been almost recoded
                            always to do its job perfectly, and to be modified
                            in an easier way.

version 1.5                 Major changes! Sound engine now supports sound
March, the 25th 1999        resampling! Added the DQBscrollArea function, plus
                            a high precision timer, pixel-perfect collision
                            detection, a fast FLI player, and new font
                            routines (now also with support for textured
                            text!). Also lots of general purpose functions;
                            the library has been speeded up a little, and
                            there are several bug-fixes. The DQBMAKE batch
                            utility has been replaced by the user-friendly
                            DirectQB Library Manager program, that allows you
                            to select each module to add to your copy of DQB,
                            and builds an optimized DIRECTQB.BI file for you
                            automatically.

version 1.51                Minor bugfixes, plus the new DQBcollideOnLayer
April, the 8th 1999         function, and the DQB Library Manager 1.1, with
                            autodetection of your QuickBasic 4.5 directory.

version 1.6                 Major, and maybe last DirectQB release. Added
May, the 29th 1999          support for up to 10 blender maps active at the
                            same time, datafiles, improved sound quality,
                            any size image load/save, new layer copy routines,
                            improved font routines, support for Windows long
                            filenames, many bugfixes and the new DQB DataFile
                            Encoder program. Also the bug with the DQB Library
                            Manager directory finder has been fixed.

version 1.61                Minor bugfixes, DQBpPut function added, datafile
June, the 1st 1999          handling routines modified to work with numbers
                            as packet IDs instead of strings


=============================================================================
APPENDIX F - Inside library modules
=============================================================================

Here's the list of functions contained in each of the OBJ files that make
the DirectQB library. Every time you'll use a function, you'll need the
correspondent module, that will be also linked to your final program
executable file. By default, all these modules are included into the library;
you can build your own custom set of routines by combining them. See section
1.5 of this manual for details.

MAIN.OBJ        - DQBinit, DQBver, DQBmapLayer, DQBclose, DQBsort, DQBinitVGA,
                  DQBinitText, DQBsetBaseLayer, DQBcopyLayer, DQBclearLayer,
                  DQBwait, DQBsetFrameRate, DQBframeReady, DQBangle, DQBerror$
                  DQBid$, DQBpeek, DQBpoke
DRAW.OBJ        - DQBcopyTransLayer, DQBcopyHitLayer, DQBpset, DQBpoint,
                  DQBline, DQBgline, DQBellipse, DQBbox, DQBboxf, DQBpaint,
                  DQBscroll, DQBscrollArea, DQBsetTransPut, DQBsetSolidPut,
                  DQBget, DQBput
IMAGE.OBJ       - DQBloadImage, DQBsaveImage, DQBplayFLI, DQBopenFLI,
                  DQBplayFLIstep, DQBcloseFLI
SPRITE.OBJ      - DQBsize, DQBsetClipBox, DQBsPut, DQBrPut, DQBfPut, DQBxPut,
                  DQBmPut, DQBhPut, DQBtPut, DQBpPut, DQBputOver, DQBcollide,
                  DQBcollideOnLayer, DQBsetCollideMethod
BIT.OBJ         - DQBsetBit, DQBresetBit, DQBreadBit, DQBtoggleBit,
                  DQBshiftLeft, DQBshiftRight
PALETTE.OBJ     - DQBsetCol, DQBgetCol, DQBfindCol, DQBfindPalCol, DQBsetPal,
                  DQBgetPal, DQBfadeIn, DQBfadeStepIn, DQBfadeTo,
                  DQBfadeStepTo, DQBpalOff, DQBpalRotate
FONT.OBJ        - DQBprint, DQBprints, DQBlen, DQBsetBIOSfont, DQBsetFont,
                  DQBsetTextBackCol, DQBsetTextStyle, DQBsetFontTexture,
                  DQBloadFont, DQBsetTextSpacing, DQBsetTextBMap
DISK.OBJ        - DQBdir$, DQBdrive$, DQBpath$, DQBnumDrives, DQBsetDrive$,
                  DQBchDir
BLENDING.OBJ    - DQBfilterBox, DQBbPut, DQBcreateBMap, DQBsetBMap, DQBgetBMap,
                  DQBcopyBlendLayer, DQBloadBMap, DQBsaveBMap, DQBremoveBMap
KEYBOARD.OBJ    - DQBinstallKeyboard, DQBremoveKeyboard, DQBkey, DQBreadKey,
                  DQBwaitKey, DQBasc, DQBinkey$
JOYSTICK.OBJ    - DQBjoyDetected, DQBpollJoy, DQBjoyX, DQBjoyY, DQBjoyMove,
                  DQBjoyFire, DQBresetJoy, DQBsetJoySens
MOUSE.OBJ       - DQBmouseDetected, DQBmouseX, DQBmouseY, DQBmouseLB,
                  DQBmouseRB, DQBsetMousePos, DQBmouseShow, DQBmouseHide
                  DQBsetMouseRange, DQBsetMouseShape, DQBsetMouseSpeed,
                  DQBresetMouse
SOUND.OBJ       - DQBinstallSB, DQBloadSound, DQBloadRawSound, DQBplaySound,
                  DQBinUse, DQBpauseSound, DQBresumeSound, DQBstopVoice,
                  DQBsetVoiceVol, DQBremoveSB, DQBsetVolume
3D.OBJ          - DQBtri, DQBgtri, DQBttri, DQBbtri, DQBbgtri, DQBbttri,
                  DQBfttri, DQBsetTextureSize
DATAFILE.OBJ    - DQBopenDataFile, DQBunpackImage, DQBunpackSprite,
                  DQBunpackSound, DQBunpackPalette, DQBunpackBMap,
                  DQBunpackFont, DQBunpackCursor, DQBunpackUser,
                  DQBcloseDataFile


=============================================================================
APPENDIX G - Error messages
=============================================================================

DirectQB has a built-in error messaging system; this means that whenever a
function fails, other than the error code returned by the function itself, an
error message is stored into a string that can be retrieved at any time, by
simply calling DQBerror$. You can use this function to prompt the user for
the exact error occured, without having to write your own custom error
handler, to handle all the possible DQB error messages. An example on using
this system follows here:

' ... suppose you want to initialize the library with 7 layers, 5 sounds
' and 120 KB of free EMS memory:
IF DQBinit(7, 5, 120) THEN DQBclose: PRINT DQBerror$: END
' If we get here, DQB was successfully initialized

If the DQBinit call fails (almost all the DQB functions return a non-zero
value on errors), DQBclose is called to avoid possible conflicts, and then the
proper error message is prompted to the user, and the program ends. What is
stored into DQBerror$ here depends on the function that failed; take a look at
the table below for a list of all the possible error messages:

Error message:                      May be caused by function:

"Library already initialized"       DQBinit
"386 or better CPU not found"       DQBinit
"No EMM driver detected"            DQBinit
"Not enough free EMS memory"        DQBinit
"Unable to open file"               DQBloadImage, DQBplayFLI, DQBloadFont,
                                    DQBloadBMap, DQBloadSound, DQBloadRawSound
"General file reading error"        DQBloadImage, DQBplayFLI, DQBloadFont,
                                    DQBloadBMap, DQBloadSound, DQBloadRawSound
"Blender map already allocated"     DQBcreateBMap
"Not enough free base memory"       DQBsetBaseLayer, DQBplayFLI, DQBcreateBMap,
                                    DQBinstallSB
"Blender map is not active"         DQBloadBMap, DQBsaveBMap
"Cannot create file"                DQBsaveImage, DQBsaveBMap
"General file writing error"        DQBsaveImage, DQBsaveBMap
"Unknown or bad file format"        DQBloadImage, DQBplayFLI, DQBloadSound
"No sounds initialized"             DQBinstallSB
"DMA channel not supported"         DQBinstallSB
"Failed to reset sound card DSP"    DQBinstallSB
"High mixing speed not supported"   DQBinstallSB
"Old sound card not supported"      DQBinstallSB
"File format not supported"         DQBloadSound
"Sound exceed 64k size limit"       DQBloadSound
"Unknown sound slot"                DQBloadSound, DQBloadRawSound,
                                    DQBunpackSound
"Cannot read past end of file"      DQBloadRawSound
"Can't open two FLI files at once"  DQBplayFLI, DQBopenFLI
"Incompatible blender map"          DQBloadBMap, DQBunpackBMap
"BLASTER variable not set"          DQBinstallSB
"Sound engine not yet initialized"  <reserved for future use>
"Datafile not yet opened"           DQBunpackFont, DQBunpackImage,
                                    DQBunpackSprite, DQBunpackSound,
                                    DQBunpackBMap, DQBunpackPal,
                                    DQBunpackCursor, DQBunpackUser
"Unknown packet ID"                 DQBunpackFont, DQBunpackImage,
                                    DQBunpackSprite, DQBunpackSound,
                                    DQBunpackBMap, DQBunpackPal,
                                    DQBunpackCursor, DQBunpackUser
"Bad password or corrupted data"    DQBunpackFont, DQBunpackImage,
                                    DQBunpackSprite, DQBunpackSound,
                                    DQBunpackBMap, DQBunpackPal,
                                    DQBunpackCursor, DQBunpackUser
"Can't open two datafiles at once"  DQBopenDataFile
"Operation successful"              Guess?


=============================================================================
Credits and final words
=============================================================================

DirectQB has been coded by Angelo Mottola of Enhanced Creations 1998-99

Special thanks go to:

Petter Holmberg - for the original QB version of the core algorithm used for
          DQBpaint, many other hints and for his constant help and interest
          in my work
Rich Geldreich - for the original QB algorithm used by DQBellipse
The PC Game Programmers Encyclopedia - as an infinite source of informations
Peter Norton - for his great online guide to assembly language
Ralph Brown - for his huge and detailed list of DOS interrupts

...and all of you on the EC wwwboard and on ICQ for your constant support
and your many suggestions that bring me to constantly improve DQB


If you have any hints, suggestions or bug reports, please contact me using
one of the following methods:

                       E-mail: angelillo@bigfoot.com
                               ICQ: 24084401
                  ICQ pager: 24084401@pager.mirabilis.com

Visit also the Enhanced Creations Homepage located at:

                        http://echome.hypermart.net
               (soon under http://ec.quickbasic.com - I hope!)

DirectQB is freeware. The only thing I'm asking you is that you write my name
somewhere in the credits section of your games if you use it.
Once finished, it would be nice for me to see your work!

Thanks for using DirectQB, and please excuse my bad english!

